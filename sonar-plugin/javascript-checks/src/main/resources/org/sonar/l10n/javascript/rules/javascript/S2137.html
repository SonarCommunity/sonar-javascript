<h2>Why is this an issue?</h2>
<p>JavaScript has special identifiers that, while not reserved, still should not be used as identifiers. They form the JavaScript standard built-in
objects and are available in all environments. They include identifiers like:</p>
<ul>
  <li> <code>eval</code> - Evaluates a string as JavaScript code. </li>
  <li> <code>arguments</code> - Used to access function arguments through indexed properties. It exists only inside function declarations and function
  expressions. </li>
  <li> <code>undefined</code> - Returned for values and properties that have not yet been assigned. </li>
  <li> <code>NaN</code> - Not a Number; returned when math functions fail. </li>
  <li> <code>Infinity</code> - When a number exceeds the upper limit of the floating point numbers. </li>
</ul>
<p>These words should not be bound or assigned, because doing so would overwrite the original definitions of these identifiers. Whatâ€™s more, assigning
or binding some of these names will generate an error in JavaScript strict mode code.</p>
<h3>Noncompliant code example</h3>
<pre>
eval = 17; // Noncompliant
arguments++; // Noncompliant
++eval; // Noncompliant
const obj = { set p(arguments) { } }; // Noncompliant
let eval; // Noncompliant
try { /* ... */ } catch (arguments) { } // Noncompliant
function x(eval) { /* ... */ } // Noncompliant
function arguments() { /* ... */ } // Noncompliant
const y = function eval() { /* ... */ }; // Noncompliant

function fun() {
  if (arguments.length == 0) { // Compliant
    // do something
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
result = 17;
args++;
++result;
const obj = { set p(arg) { } };
let result;
try { /* ... */ } catch (args) { }
function x(arg) { /* ... */ }
function args() { /* ... */ }
const y = function fun() { /* ... */ };

function fun() {
  if (arguments.length == 0) {
    // do something
  }
}
</pre>

