binary_and_unary_expressions.binary (x#1) {
bb0:
  #2 = call #binop is#(param x#1, null#0)
  #3 = call #binop is not#(param x#1, null#0)
  #4 = call #binop ==#(param x#1, null#0)
  #5 = call #binop !=#(param x#1, null#0)
  return null#0
}
binary_and_unary_expressions.unary (x#1) {
bb0:
  #2 = call #unaryop !#(param x#1):bool
  return null#0
}
binary_and_unary_expressions.binary_and () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  brif bb1, bb2, a#2
bb1:
  br bb2
bb2:
  #5 = phi(bb0: a#2, bb1: b#4)
  brif bb3, bb4, #5
bb3:
  x#6 = call #id#(1#1):int
  br bb5
bb4:
  x#7 = call #id#(2#3):int
  br bb5
bb5:
  x#9 = call #id#(3#8):int
  return null#0
}
binary_and_unary_expressions.binary_and_chained () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  c#6 = call #id#(3#5):int
  brif bb1, bb2, a#2
bb1:
  br bb2
bb2:
  #7 = phi(bb0: a#2, bb1: b#4)
  brif bb3, bb4, #7
bb3:
  br bb4
bb4:
  #9 = phi(bb2: #7, bb3: c#6)
  brif bb5, bb6, #9
bb5:
  x#10 = call #id#(1#1):int
  br bb7
bb6:
  x#11 = call #id#(2#3):int
  br bb7
bb7:
  x#12 = call #id#(3#5):int
  return null#0
}
binary_and_unary_expressions.binary_or () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  brif bb2, bb1, a#2
bb1:
  br bb2
bb2:
  #5 = phi(bb0: a#2, bb1: b#4)
  brif bb3, bb4, #5
bb3:
  x#6 = call #id#(1#1):int
  br bb5
bb4:
  x#7 = call #id#(2#3):int
  br bb5
bb5:
  x#9 = call #id#(3#8):int
  return null#0
}
binary_and_unary_expressions.binary_or_chained () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  c#6 = call #id#(3#5):int
  brif bb2, bb1, a#2
bb1:
  br bb2
bb2:
  #7 = phi(bb0: a#2, bb1: b#4)
  brif bb4, bb3, #7
bb3:
  br bb4
bb4:
  #9 = phi(bb2: #7, bb3: c#6)
  brif bb5, bb6, #9
bb5:
  x#10 = call #id#(1#1):int
  br bb7
bb6:
  x#11 = call #id#(2#3):int
  br bb7
bb7:
  x#12 = call #id#(3#5):int
  return null#0
}
binary_and_unary_expressions.binary_and_or () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  c#6 = call #id#(3#5):int
  brif bb1, bb2, a#2
bb1:
  br bb2
bb2:
  #7 = phi(bb0: a#2, bb1: b#4)
  brif bb4, bb3, #7
bb3:
  br bb4
bb4:
  #9 = phi(bb2: #7, bb3: c#6)
  brif bb5, bb6, #9
bb5:
  x#10 = call #id#(1#1):int
  br bb7
bb6:
  x#11 = call #id#(2#3):int
  br bb7
bb7:
  x#12 = call #id#(3#5):int
  return null#0
}
binary_and_unary_expressions.nested_is (a#1, b#2) {
bb0:
  #3 = call #binop is#(param a#1, param b#2)
  brif bb1, bb2, #3
bb1:
  #4 = call #binop is#(param b#2, null#0)
  br bb2
bb2:
  #6 = phi(bb0: false#5, bb1: #4)
  brif bb3, bb4, #6
bb3:
  x#8 = call #id#(1#7):int
  br bb5
bb4:
  x#10 = call #id#(2#9):int
  br bb5
bb5:
  x#12 = call #id#(3#11):int
  return null#0
}
binary_and_unary_expressions.nested_is_2 (a#1, b#2, c#3, d#4) {
bb0:
  #5 = call #binop is#(param a#1, param b#2)
  brif bb1, bb2, #5
bb1:
  #6 = call #binop is#(param b#2, param c#3)
  br bb2
bb2:
  #8 = phi(bb0: false#7, bb1: #6)
  brif bb3, bb4, #8
bb3:
  #10 = call #binop is#(param c#3, param d#4)
  br bb4
bb4:
  #11 = phi(bb2: false#7, bb3: #10)
  brif bb5, bb6, #11
bb5:
  x#13 = call #id#(1#12):int
  br bb7
bb6:
  x#15 = call #id#(2#14):int
  br bb7
bb7:
  x#17 = call #id#(3#16):int
  return null#0
}
binary_and_unary_expressions.nested_is_not (a#1, b#2) {
bb0:
  #3 = call #binop is#(param a#1, param b#2)
  brif bb1, bb2, #3
bb1:
  #4 = call #binop is not#(param b#2, null#0)
  br bb2
bb2:
  #6 = phi(bb0: false#5, bb1: #4)
  brif bb3, bb4, #6
bb3:
  x#8 = call #id#(1#7):int
  br bb5
bb4:
  x#10 = call #id#(2#9):int
  br bb5
bb5:
  x#12 = call #id#(3#11):int
  return null#0
}
binary_and_unary_expressions.nested_is_not_2 (a#1, b#2, c#3) {
bb0:
  #4 = call #binop is not#(param a#1, param b#2)
  brif bb1, bb2, #4
bb1:
  #5 = call #binop is not#(param b#2, param c#3)
  br bb2
bb2:
  #7 = phi(bb0: false#6, bb1: #5)
  brif bb3, bb4, #7
bb3:
  x#9 = call #id#(1#8):int
  br bb5
bb4:
  x#11 = call #id#(2#10):int
  br bb5
bb5:
  x#13 = call #id#(3#12):int
  return null#0
}
binary_and_unary_expressions.nested_is_assigned_to_variable (x#1, y#2, z#3) {
bb0:
  #4 = call ?.x()
  #5 = call ?.y()
  a#6 = call #binop is#(#4, #5)
  #7 = call ?.x()
  #8 = call ?.y()
  #9 = call #binop is#(#7, #8)
  brif bb1, bb2, #9
bb1:
  #10 = call ?.z()
  #11 = call #binop is#(#8, #10)
  br bb2
bb2:
  b#13 = phi(bb0: false#12, bb1: #11)
  return null#0
}
binary_and_unary_expressions.plus_operator (x#1, y#2) {
bb0:
  z#3 = call #binop +#(param x#1, param y#2)
  #4 = call #binop +#(param x#1, param y#2, z#3)
  return #4
}
binary_and_unary_expressions.unpacking_expression (param#1) {
bb0:
  #2 = call #unaryop **#(param param#1)
  #3 = call #unknown#(#2)
  #4 = call #unaryop *#(param param#1)
  #5 = call #unknown#(#4)
  d#6 = call #new-object#():dict
  #9 = call #map-set#(d#6, k1#7, 42#8)
  #10 = call #unaryop **#(param param#1)
  #11 = call #map-set-all#(d#6, #10)
  return null#0
}
binary_and_unary_expressions.binary_and_with_function_call () {
bb0:
  a#2 = call #id#(1#1):int
  b#4 = call #id#(2#3):int
  brif bb1, bb2, a#2
bb1:
  #5 = call binary_and_unary_expressions.unary(b#4)
  br bb2
bb2:
  #6 = phi(bb0: a#2, bb1: #5)
  brif bb3, bb4, #6
bb3:
  x#7 = call #id#(1#1):int
  br bb5
bb4:
  x#8 = call #id#(2#3):int
  br bb5
bb5:
  return null#0
}
binary_and_unary_expressions.if_in (d#1) {
bb0:
  #3 = call #binop in#(k1#2, param d#1)
  brif bb1, bb2, #3
bb1:
  #5 = call print(k#4):NoneType
  br bb2
bb2:
  #8 = call #binop not in#(k2#6, param d#1)
  brif bb3, bb4, #8
bb3:
  #9 = call print(k2#6):NoneType
  br bb4
bb4:
  return null#0
}
binary_and_unary_expressions.binary_arithmetic_operators (x#1, y#2, z#3) {
bb0:
  plus#4 = call #binop +#(param x#1, param y#2)
  plusMultiple#5 = call #binop +#(param x#1, param y#2, param z#3)
  minus#6 = call #binop -#(param x#1, param y#2)
  #7 = call #binop -#(param x#1, param y#2)
  minusMultiple#8 = call #binop -#(#7, param z#3)
  multiply#9 = call #binop *#(param x#1, param y#2)
  #10 = call #binop *#(param x#1, param y#2)
  multiplyMultiple#11 = call #binop *#(#10, param z#3)
  divide#12 = call #binop /#(param x#1, param y#2)
  #13 = call #binop /#(param x#1, param y#2)
  divideMultiple#14 = call #binop /#(#13, param z#3)
  mod#15 = call #binop %#(param x#1, param y#2)
  #16 = call #binop %#(param x#1, param y#2)
  modMultiple#17 = call #binop %#(#16, param z#3)
  power#18 = call #binop **#(param x#1, param y#2)
  #19 = call #binop **#(param y#2, param z#3)
  powerMultiple#20 = call #binop **#(param x#1, #19)
  return null#0
}
binary_and_unary_expressions.mix_of_binary_arithmetic_operators () {
bb0:
  #3 = call #binop *#(5#1, 1#2)
  #6 = call #binop *#(2#4, 3#5)
  mix#7 = call #binop +#(#3, #6)
  #9 = call #binop *#(3#5, 6#8)
  mix2#10 = call #binop /#(#9, 3#5)
  #12 = call #binop **#(5#1, 2#4)
  mix3#13 = call #binop %#(9#11, #12)
  #15 = call #binop *#(5#1, 3#5)
  mix4#17 = call #binop +#(2#4, 3#5, 4#14, #15, 2#4, 7#16)
  return null#0
}
