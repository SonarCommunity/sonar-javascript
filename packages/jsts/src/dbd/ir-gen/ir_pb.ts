// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file ir.proto (package sonarsource.ir, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { Message, proto3 } from '@bufbuild/protobuf';

/**
 * @generated from message sonarsource.ir.ValueTable
 */
export class ValueTable extends Message<ValueTable> {
  /**
   * @generated from field: sonarsource.ir.Null null = 1;
   */
  null?: Null;

  /**
   * @generated from field: repeated sonarsource.ir.Constant constants = 2;
   */
  constants: Constant[] = [];

  /**
   * @generated from field: repeated sonarsource.ir.Parameter parameters = 3;
   */
  parameters: Parameter[] = [];

  /**
   * @generated from field: repeated sonarsource.ir.TypeName typeNames = 4;
   */
  typeNames: TypeName[] = [];

  constructor(data?: PartialMessage<ValueTable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.ValueTable';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'null', kind: 'message', T: Null },
    { no: 2, name: 'constants', kind: 'message', T: Constant, repeated: true },
    { no: 3, name: 'parameters', kind: 'message', T: Parameter, repeated: true },
    { no: 4, name: 'typeNames', kind: 'message', T: TypeName, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueTable {
    return new ValueTable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueTable {
    return new ValueTable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueTable {
    return new ValueTable().fromJsonString(jsonString, options);
  }

  static equals(
    a: ValueTable | PlainMessage<ValueTable> | undefined,
    b: ValueTable | PlainMessage<ValueTable> | undefined,
  ): boolean {
    return proto3.util.equals(ValueTable, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.FunctionInfo
 */
export class FunctionInfo extends Message<FunctionInfo> {
  /**
   * @generated from field: sonarsource.ir.FunctionId function_id = 1;
   */
  functionId?: FunctionId;

  /**
   * @generated from field: sonarsource.ir.ValueTable values = 2;
   */
  values?: ValueTable;

  /**
   * @generated from field: repeated sonarsource.ir.Parameter parameters = 3;
   */
  parameters: Parameter[] = [];

  /**
   * @generated from field: repeated sonarsource.ir.BasicBlock basic_blocks = 4;
   */
  basicBlocks: BasicBlock[] = [];

  /**
   * fileId is the absolute path to the file
   *
   * @generated from field: string file_id = 5;
   */
  fileId = '';

  constructor(data?: PartialMessage<FunctionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.FunctionInfo';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'function_id', kind: 'message', T: FunctionId },
    { no: 2, name: 'values', kind: 'message', T: ValueTable },
    { no: 3, name: 'parameters', kind: 'message', T: Parameter, repeated: true },
    { no: 4, name: 'basic_blocks', kind: 'message', T: BasicBlock, repeated: true },
    { no: 5, name: 'file_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FunctionInfo {
    return new FunctionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FunctionInfo {
    return new FunctionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FunctionInfo {
    return new FunctionInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: FunctionInfo | PlainMessage<FunctionInfo> | undefined,
    b: FunctionInfo | PlainMessage<FunctionInfo> | undefined,
  ): boolean {
    return proto3.util.equals(FunctionInfo, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.FunctionId
 */
export class FunctionId extends Message<FunctionId> {
  /**
   * @generated from field: string simple_name = 1;
   */
  simpleName = '';

  /**
   * @generated from field: optional string signature = 2;
   */
  signature?: string;

  /**
   * @generated from field: optional sonarsource.ir.TypeInfo return_type = 3;
   */
  returnType?: TypeInfo;

  /**
   * @generated from field: bool isVirtual = 4;
   */
  isVirtual = false;

  /**
   * @generated from field: bool is_standard_library_function = 5;
   */
  isStandardLibraryFunction = false;

  /**
   * @generated from field: bool isFunctionRef = 6;
   */
  isFunctionRef = false;

  constructor(data?: PartialMessage<FunctionId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.FunctionId';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'simple_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'signature', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: 'return_type', kind: 'message', T: TypeInfo, opt: true },
    { no: 4, name: 'isVirtual', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: 'is_standard_library_function', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: 'isFunctionRef', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FunctionId {
    return new FunctionId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FunctionId {
    return new FunctionId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FunctionId {
    return new FunctionId().fromJsonString(jsonString, options);
  }

  static equals(
    a: FunctionId | PlainMessage<FunctionId> | undefined,
    b: FunctionId | PlainMessage<FunctionId> | undefined,
  ): boolean {
    return proto3.util.equals(FunctionId, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.BasicBlock
 */
export class BasicBlock extends Message<BasicBlock> {
  /**
   * @generated from field: int32 id = 1;
   */
  id = 0;

  /**
   * @generated from field: repeated sonarsource.ir.Instruction instructions = 2;
   */
  instructions: Instruction[] = [];

  /**
   * @generated from field: optional sonarsource.ir.BasicBlock exception_handler = 3;
   */
  exceptionHandler?: BasicBlock;

  /**
   * @generated from field: optional sonarsource.ir.Location location = 4;
   */
  location?: Location;

  /**
   * @generated from field: optional int32 loopId = 5;
   */
  loopId?: number;

  /**
   * @generated from field: optional int32 parentLoopId = 6;
   */
  parentLoopId?: number;

  /**
   * @generated from field: bool isLoopCondition = 7;
   */
  isLoopCondition = false;

  constructor(data?: PartialMessage<BasicBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.BasicBlock';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'instructions', kind: 'message', T: Instruction, repeated: true },
    { no: 3, name: 'exception_handler', kind: 'message', T: BasicBlock, opt: true },
    { no: 4, name: 'location', kind: 'message', T: Location, opt: true },
    { no: 5, name: 'loopId', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: 'parentLoopId', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: 'isLoopCondition', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicBlock {
    return new BasicBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicBlock {
    return new BasicBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicBlock {
    return new BasicBlock().fromJsonString(jsonString, options);
  }

  static equals(
    a: BasicBlock | PlainMessage<BasicBlock> | undefined,
    b: BasicBlock | PlainMessage<BasicBlock> | undefined,
  ): boolean {
    return proto3.util.equals(BasicBlock, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.Instruction
 */
export class Instruction extends Message<Instruction> {
  /**
   * @generated from oneof sonarsource.ir.Instruction.instr
   */
  instr:
    | {
        /**
         * @generated from field: sonarsource.ir.CallInstruction call_instruction = 1;
         */
        value: CallInstruction;
        case: 'callInstruction';
      }
    | {
        /**
         * @generated from field: sonarsource.ir.ReturnInstruction return_instruction = 2;
         */
        value: ReturnInstruction;
        case: 'returnInstruction';
      }
    | {
        /**
         * @generated from field: sonarsource.ir.BranchingInstruction branching_instruction = 3;
         */
        value: BranchingInstruction;
        case: 'branchingInstruction';
      }
    | {
        /**
         * @generated from field: sonarsource.ir.ConditionalBranchingInstruction conditional_branching_instruction = 4;
         */
        value: ConditionalBranchingInstruction;
        case: 'conditionalBranchingInstruction';
      }
    | {
        /**
         * @generated from field: sonarsource.ir.PhiInstruction phi_instruction = 5;
         */
        value: PhiInstruction;
        case: 'phiInstruction';
      }
    | {
        /**
         * @generated from field: sonarsource.ir.ThrowInstruction throw_instruction = 6;
         */
        value: ThrowInstruction;
        case: 'throwInstruction';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Instruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.Instruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'call_instruction', kind: 'message', T: CallInstruction, oneof: 'instr' },
    { no: 2, name: 'return_instruction', kind: 'message', T: ReturnInstruction, oneof: 'instr' },
    {
      no: 3,
      name: 'branching_instruction',
      kind: 'message',
      T: BranchingInstruction,
      oneof: 'instr',
    },
    {
      no: 4,
      name: 'conditional_branching_instruction',
      kind: 'message',
      T: ConditionalBranchingInstruction,
      oneof: 'instr',
    },
    { no: 5, name: 'phi_instruction', kind: 'message', T: PhiInstruction, oneof: 'instr' },
    { no: 6, name: 'throw_instruction', kind: 'message', T: ThrowInstruction, oneof: 'instr' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Instruction {
    return new Instruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Instruction {
    return new Instruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: Instruction | PlainMessage<Instruction> | undefined,
    b: Instruction | PlainMessage<Instruction> | undefined,
  ): boolean {
    return proto3.util.equals(Instruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.CallInstruction
 */
export class CallInstruction extends Message<CallInstruction> {
  /**
   * @generated from field: sonarsource.ir.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: int32 value_id = 2;
   */
  valueId = 0;

  /**
   * @generated from field: optional string variable_name = 3;
   */
  variableName?: string;

  /**
   * @generated from field: sonarsource.ir.FunctionId function_id = 4;
   */
  functionId?: FunctionId;

  /**
   * @generated from field: repeated int32 arguments = 5;
   */
  arguments: number[] = [];

  /**
   * @generated from field: optional sonarsource.ir.TypeInfo staticType = 6;
   */
  staticType?: TypeInfo;

  /**
   * @generated from field: bool isInstanceMethodCall = 7;
   */
  isInstanceMethodCall = false;

  constructor(data?: PartialMessage<CallInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.CallInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'location', kind: 'message', T: Location },
    { no: 2, name: 'value_id', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: 'variable_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: 'function_id', kind: 'message', T: FunctionId },
    { no: 5, name: 'arguments', kind: 'scalar', T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 6, name: 'staticType', kind: 'message', T: TypeInfo, opt: true },
    { no: 7, name: 'isInstanceMethodCall', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallInstruction {
    return new CallInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallInstruction {
    return new CallInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallInstruction {
    return new CallInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: CallInstruction | PlainMessage<CallInstruction> | undefined,
    b: CallInstruction | PlainMessage<CallInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(CallInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.ReturnInstruction
 */
export class ReturnInstruction extends Message<ReturnInstruction> {
  /**
   * @generated from field: sonarsource.ir.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: optional int32 return_value = 2;
   */
  returnValue?: number;

  constructor(data?: PartialMessage<ReturnInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.ReturnInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'location', kind: 'message', T: Location },
    { no: 2, name: 'return_value', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReturnInstruction {
    return new ReturnInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReturnInstruction {
    return new ReturnInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReturnInstruction {
    return new ReturnInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: ReturnInstruction | PlainMessage<ReturnInstruction> | undefined,
    b: ReturnInstruction | PlainMessage<ReturnInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(ReturnInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.BranchingInstruction
 */
export class BranchingInstruction extends Message<BranchingInstruction> {
  /**
   * @generated from field: sonarsource.ir.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: int32 successor = 2;
   */
  successor = 0;

  constructor(data?: PartialMessage<BranchingInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.BranchingInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'location', kind: 'message', T: Location },
    { no: 2, name: 'successor', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BranchingInstruction {
    return new BranchingInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BranchingInstruction {
    return new BranchingInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): BranchingInstruction {
    return new BranchingInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: BranchingInstruction | PlainMessage<BranchingInstruction> | undefined,
    b: BranchingInstruction | PlainMessage<BranchingInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(BranchingInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.ConditionalBranchingInstruction
 */
export class ConditionalBranchingInstruction extends Message<ConditionalBranchingInstruction> {
  /**
   * @generated from field: sonarsource.ir.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: int32 condition = 2;
   */
  condition = 0;

  /**
   * @generated from field: int32 true_successor = 3;
   */
  trueSuccessor = 0;

  /**
   * @generated from field: int32 false_successor = 4;
   */
  falseSuccessor = 0;

  constructor(data?: PartialMessage<ConditionalBranchingInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.ConditionalBranchingInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'location', kind: 'message', T: Location },
    { no: 2, name: 'condition', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: 'true_successor', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: 'false_successor', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ConditionalBranchingInstruction {
    return new ConditionalBranchingInstruction().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ConditionalBranchingInstruction {
    return new ConditionalBranchingInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ConditionalBranchingInstruction {
    return new ConditionalBranchingInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConditionalBranchingInstruction | PlainMessage<ConditionalBranchingInstruction> | undefined,
    b: ConditionalBranchingInstruction | PlainMessage<ConditionalBranchingInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(ConditionalBranchingInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.PhiInstruction
 */
export class PhiInstruction extends Message<PhiInstruction> {
  /**
   * @generated from field: int32 value_id = 1;
   */
  valueId = 0;

  /**
   * @generated from field: optional string variable_name = 2;
   */
  variableName?: string;

  /**
   * @generated from field: map<int32, int32> values_by_block = 3;
   */
  valuesByBlock: { [key: number]: number } = {};

  constructor(data?: PartialMessage<PhiInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.PhiInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'value_id', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'variable_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    {
      no: 3,
      name: 'values_by_block',
      kind: 'map',
      K: 5 /* ScalarType.INT32 */,
      V: { kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PhiInstruction {
    return new PhiInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PhiInstruction {
    return new PhiInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PhiInstruction {
    return new PhiInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: PhiInstruction | PlainMessage<PhiInstruction> | undefined,
    b: PhiInstruction | PlainMessage<PhiInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(PhiInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.ThrowInstruction
 */
export class ThrowInstruction extends Message<ThrowInstruction> {
  /**
   * @generated from field: sonarsource.ir.Location location = 1;
   */
  location?: Location;

  /**
   * @generated from field: int32 exception_value = 2;
   */
  exceptionValue = 0;

  constructor(data?: PartialMessage<ThrowInstruction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.ThrowInstruction';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'location', kind: 'message', T: Location },
    { no: 2, name: 'exception_value', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThrowInstruction {
    return new ThrowInstruction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThrowInstruction {
    return new ThrowInstruction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThrowInstruction {
    return new ThrowInstruction().fromJsonString(jsonString, options);
  }

  static equals(
    a: ThrowInstruction | PlainMessage<ThrowInstruction> | undefined,
    b: ThrowInstruction | PlainMessage<ThrowInstruction> | undefined,
  ): boolean {
    return proto3.util.equals(ThrowInstruction, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.Constant
 */
export class Constant extends Message<Constant> {
  /**
   * @generated from field: int32 valueId = 1;
   */
  valueId = 0;

  /**
   * @generated from field: string value = 2;
   */
  value = '';

  /**
   * @generated from field: optional sonarsource.ir.TypeInfo typeInfo = 3;
   */
  typeInfo?: TypeInfo;

  constructor(data?: PartialMessage<Constant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.Constant';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'valueId', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'typeInfo', kind: 'message', T: TypeInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Constant {
    return new Constant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Constant {
    return new Constant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Constant {
    return new Constant().fromJsonString(jsonString, options);
  }

  static equals(
    a: Constant | PlainMessage<Constant> | undefined,
    b: Constant | PlainMessage<Constant> | undefined,
  ): boolean {
    return proto3.util.equals(Constant, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.Null
 */
export class Null extends Message<Null> {
  /**
   * @generated from field: int32 valueId = 1;
   */
  valueId = 0;

  constructor(data?: PartialMessage<Null>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.Null';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'valueId', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Null {
    return new Null().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Null {
    return new Null().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Null {
    return new Null().fromJsonString(jsonString, options);
  }

  static equals(
    a: Null | PlainMessage<Null> | undefined,
    b: Null | PlainMessage<Null> | undefined,
  ): boolean {
    return proto3.util.equals(Null, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.Parameter
 */
export class Parameter extends Message<Parameter> {
  /**
   * @generated from field: int32 valueId = 1;
   */
  valueId = 0;

  /**
   * @generated from field: string name = 2;
   */
  name = '';

  /**
   * @generated from field: sonarsource.ir.Location definitionLocation = 3;
   */
  definitionLocation?: Location;

  /**
   * @generated from field: optional sonarsource.ir.TypeInfo typeInfo = 4;
   */
  typeInfo?: TypeInfo;

  constructor(data?: PartialMessage<Parameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.Parameter';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'valueId', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'definitionLocation', kind: 'message', T: Location },
    { no: 4, name: 'typeInfo', kind: 'message', T: TypeInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Parameter {
    return new Parameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJsonString(jsonString, options);
  }

  static equals(
    a: Parameter | PlainMessage<Parameter> | undefined,
    b: Parameter | PlainMessage<Parameter> | undefined,
  ): boolean {
    return proto3.util.equals(Parameter, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.TypeInfo
 */
export class TypeInfo extends Message<TypeInfo> {
  /**
   * @generated from field: sonarsource.ir.TypeInfo.Kind kind = 1;
   */
  kind = TypeInfo_Kind.PRIMITIVE;

  /**
   * @generated from field: string qualified_name = 2;
   */
  qualifiedName = '';

  /**
   * @generated from field: repeated string super_types = 3;
   */
  superTypes: string[] = [];

  /**
   * @generated from field: bool has_incomplete_semantics = 4;
   */
  hasIncompleteSemantics = false;

  constructor(data?: PartialMessage<TypeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.TypeInfo';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'kind', kind: 'enum', T: proto3.getEnumType(TypeInfo_Kind) },
    { no: 2, name: 'qualified_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'super_types', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: 'has_incomplete_semantics', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeInfo {
    return new TypeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeInfo {
    return new TypeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeInfo {
    return new TypeInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: TypeInfo | PlainMessage<TypeInfo> | undefined,
    b: TypeInfo | PlainMessage<TypeInfo> | undefined,
  ): boolean {
    return proto3.util.equals(TypeInfo, a, b);
  }
}

/**
 * @generated from enum sonarsource.ir.TypeInfo.Kind
 */
export enum TypeInfo_Kind {
  /**
   * @generated from enum value: PRIMITIVE = 0;
   */
  PRIMITIVE = 0,

  /**
   * @generated from enum value: CLASS = 1;
   */
  CLASS = 1,

  /**
   * @generated from enum value: INTERFACE = 2;
   */
  INTERFACE = 2,

  /**
   * @generated from enum value: ARRAY = 3;
   */
  ARRAY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TypeInfo_Kind)
proto3.util.setEnumType(TypeInfo_Kind, 'sonarsource.ir.TypeInfo.Kind', [
  { no: 0, name: 'PRIMITIVE' },
  { no: 1, name: 'CLASS' },
  { no: 2, name: 'INTERFACE' },
  { no: 3, name: 'ARRAY' },
]);

/**
 * @generated from message sonarsource.ir.TypeName
 */
export class TypeName extends Message<TypeName> {
  /**
   * @generated from field: int32 valueId = 1;
   */
  valueId = 0;

  /**
   * @generated from field: string name = 2;
   */
  name = '';

  /**
   * @generated from field: optional sonarsource.ir.TypeInfo type_info = 3;
   */
  typeInfo?: TypeInfo;

  constructor(data?: PartialMessage<TypeName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.TypeName';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'valueId', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'type_info', kind: 'message', T: TypeInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeName {
    return new TypeName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeName {
    return new TypeName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeName {
    return new TypeName().fromJsonString(jsonString, options);
  }

  static equals(
    a: TypeName | PlainMessage<TypeName> | undefined,
    b: TypeName | PlainMessage<TypeName> | undefined,
  ): boolean {
    return proto3.util.equals(TypeName, a, b);
  }
}

/**
 * @generated from message sonarsource.ir.Location
 */
export class Location extends Message<Location> {
  /**
   * The field `file_id` is normally unused, as the file name for the location should be set on the FunctionInfo
   * object (see DBD-329). However, we still keep it to preserve backwards compatibility and make it possible
   * to override the default behavior by setting a non-empty string to this field.
   *
   * @generated from field: string file_id = 1;
   */
  fileId = '';

  /**
   * @generated from field: int32 start_line = 2;
   */
  startLine = 0;

  /**
   * @generated from field: int32 start_column = 3;
   */
  startColumn = 0;

  /**
   * @generated from field: int32 end_line = 4;
   */
  endLine = 0;

  /**
   * @generated from field: int32 end_column = 5;
   */
  endColumn = 0;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'sonarsource.ir.Location';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'file_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'start_line', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: 'start_column', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: 'end_line', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: 'end_column', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(
    a: Location | PlainMessage<Location> | undefined,
    b: Location | PlainMessage<Location> | undefined,
  ): boolean {
    return proto3.util.equals(Location, a, b);
  }
}
