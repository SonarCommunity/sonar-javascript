/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2023 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
import * as path from 'path';
import * as os from 'os';
import { AnalysisInput, FileFinder, FileType, setContext, toUnixPath } from '../../shared/src';
import {
  DEFAULT_ENVIRONMENTS,
  DEFAULT_GLOBALS,
  JsTsFiles,
  ProjectAnalysisInput,
  ProjectAnalysisOutput,
  RuleConfig,
  analyzeProject,
  initializeLinter,
} from '../../jsts/src';
import { accept } from '../filter/JavaScriptExclusionsFilter';
import { writeResults } from './lits';
import { analyzeHTML } from '../../html/src';
import { analyzeYAML } from '../../yaml/src';
import projects from '../data/projects.json';
/**
 * The rules.json file was generated by running the ruling test with `.setDebugLogs(true)`
 * and capturing the `inputRules` parameter from `packages/jsts/src/linter/linters.ts#initializeLinter()`
 */
import rules from '../data/rules.json';
import { getLanguage } from './languages';
const PATTERNS = {
  html: '*.html,*.htm',
  yaml: '*.yaml,*.yml',
  jsts: '*.js,*.mjs,*.cjs,*.jsx,*.vue,*.ts,*.mts,*.cts,*.tsx',
};

const sourcesPath = path.join(__dirname, '..', '..', '..', '..', 'rulingSources');
const jsTsProjectsPath = path.join(sourcesPath, 'jsts', 'projects');

const expectedPath = path.join(
  __dirname,
  '..',
  '..',
  '..',
  'its',
  'ruling',
  'src',
  'test',
  'expected',
  'jsts',
);
const actualPath = path.join(__dirname, '..', 'actual', 'jsts');

const HTML_LINTER_ID = 'html';

type RulingInput = {
  name: string;
  testDir?: string;
  exclusions?: string;
  folder?: string;
};

const DEFAULT_EXCLUSIONS = [
  '.*',
  '*.d.ts',
  'node_modules',
  'bower_components',
  'dist',
  'vendor',
  'external',
];

export function setupBeforeAll(projectFile: string) {
  const projectName = toUnixPath(projectFile).match(/.*\/([^\/]*)\.ruling\.test\.ts$/)?.[1];
  let project = projects.find(p => p.name === projectName);
  beforeAll(() => {
    setContext({
      workDir: path.join(os.tmpdir(), 'sonarjs'),
      shouldUseTypeScriptParserForJS: true,
      sonarlint: false,
      bundles: [],
    });
    initializeLinter(rules as RuleConfig[], DEFAULT_ENVIRONMENTS, DEFAULT_GLOBALS);
    const htmlRules = (rules as RuleConfig[]).filter(rule => rule.key !== 'no-var');
    initializeLinter(htmlRules, DEFAULT_ENVIRONMENTS, DEFAULT_GLOBALS, HTML_LINTER_ID);
  });
  return {
    project,
    expectedPath: path.join(expectedPath, project.name),
    actualPath: path.join(actualPath, project.name),
  };
}

/**
 * Load files and analyze project
 */
export async function testProject(rulingInput: RulingInput) {
  const projectPath = path.join(jsTsProjectsPath, rulingInput.folder ?? rulingInput.name);
  const exclusions = setExclusions(projectPath, rulingInput.exclusions, rulingInput.testDir).concat(
    DEFAULT_EXCLUSIONS,
  );

  const files = getProjectFiles(rulingInput, projectPath, exclusions);

  const payload: ProjectAnalysisInput = {
    rules: rules as RuleConfig[],
    baseDir: projectPath,
    files: files[PATTERNS.jsts],
  };

  const jsTsResults = await analyzeProject(payload);
  const htmlResults = await analyzeFiles(files[PATTERNS.html], analyzeHTML, HTML_LINTER_ID);
  const yamlResults = await analyzeFiles(files[PATTERNS.yaml], analyzeYAML);
  const results = mergeIssues(jsTsResults, htmlResults, yamlResults);

  writeResults(projectPath, rulingInput.name, results, files, actualPath);
}

function setExclusions(projectPath: string, exclusions: string, testDir?: string) {
  const exclusionsArray = exclusions
    ? exclusions.split(',').map(exclusion => exclusion.trim())
    : [];
  if (testDir && testDir !== '') {
    exclusionsArray.push(testDir);
  }
  return exclusionsArray.map(exclusion =>
    /^(\*\*)?\//.test(exclusion) ? exclusion : toUnixPath(path.join(projectPath, exclusion)),
  );
}

function getProjectFiles(rulingInput: RulingInput, projectPath: string, exclusions: string[]) {
  const files = {};
  for (const lang of Object.values(PATTERNS)) {
    files[lang] = {};
  }
  getFiles(files, projectPath, exclusions, 'MAIN');

  if (rulingInput.testDir != null) {
    const testFolder = path.join(projectPath, rulingInput.testDir);
    getFiles(files, testFolder, exclusions, 'TEST');
  }
  return files;
}

function getFiles(
  result: { [key: string]: JsTsFiles },
  projectPath: string,
  exclusions: string[],
  fileType: FileType,
) {
  const files = FileFinder.searchFiles(
    projectPath,
    true,
    [
      { pattern: PATTERNS.html, parser: (_, contents) => contents },
      { pattern: PATTERNS.yaml, parser: (_, contents) => contents },
      { pattern: PATTERNS.jsts, parser: (_, contents) => contents },
    ],
    exclusions,
  );

  for (const [lang, filesDB] of Object.entries(files)) {
    switch (lang) {
      case PATTERNS.html:
      case PATTERNS.yaml:
        for (const [_, files] of filesDB) {
          files.forEach(file => {
            result[lang][file.filename] = {
              fileType,
              fileContent: file.contents as string,
              language: 'js',
            };
          });
        }
        break;
      case PATTERNS.jsts:
        for (const [_, files] of filesDB) {
          files.forEach(file => {
            if (accept(file.filename, file.contents as string)) {
              result[lang][file.filename] = {
                fileType,
                fileContent: file.contents as string,
                language: getLanguage(file.filename, file.contents as string),
              };
            }
          });
        }
    }
  }
}
async function analyzeFiles(
  files: JsTsFiles,
  analyzer: (payload: AnalysisInput) => Promise<any>,
  linterId?: string,
) {
  const results = { files: {} };
  for (const [filePath, fileData] of Object.entries(files)) {
    const payload: AnalysisInput = {
      filePath,
      fileContent: fileData.fileContent,
      linterId,
    };
    try {
      const result = await analyzer(payload);
      results.files[filePath] = result;
    } catch (err) {
      results.files[filePath] = createParsingError(err);
    }
    results.files[filePath].language = fileData.language;
  }
  return results;
}

function mergeIssues(...resultsSet: ProjectAnalysisOutput[]) {
  const allResults = { files: {} };
  for (const results of resultsSet) {
    for (const [filePath, fileData] of Object.entries(results.files)) {
      if (allResults.files[filePath]) {
        throw Error(`File ${filePath} has been analyzed in multiple paths`);
      }
      if (fileData.parsingError) {
        allResults.files[filePath] = createParsingError({ data: fileData.parsingError });
      } else {
        allResults.files[filePath] = fileData;
      }
    }
  }
  return allResults;
}

function createParsingError({
  data: { line, message },
}: {
  data: { line: number; message: string };
}) {
  return {
    issues: [
      {
        ruleId: 'S2260',
        line,
        // stub values so we don't have to modify the type
        message,
        column: 0,
        secondaryLocations: [],
      },
    ],
  };
}
