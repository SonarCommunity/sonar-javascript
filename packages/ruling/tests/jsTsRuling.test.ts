/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2023 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { Minimatch } from 'minimatch';
import { FileType, setContext, toUnixPath } from '../../shared/src';
import {
  JsTsAnalysisOutput,
  JsTsFiles,
  ProjectAnalysisInput,
  ProjectAnalysisOutput,
  analyzeProject,
} from '../../jsts/src';
import { accept } from './filter/JavaScriptExclusionsFilter';
import { writeResults } from './lits';
import { HtmlAnalysisInput, analyzeHTML } from '@sonar/html';
const sourcesPath = path.join(__dirname, '..', '..', '..', 'its', 'sources');
const jsTsProjectsPath = path.join(sourcesPath, 'jsts', 'projects');

const jsExts = ['.js', '.mjs', '.cjs', '.jsx', '.vue', '.html', '.htm', '.yml', '.yaml'];

const tsExts = ['.ts', '.mts', '.cts', '.tsx'];

type RulingInput = {
  name: string;
  testDir?: string;
  exclusions?: string;
  folder?: string;
};

// cache for rules
const rules = [];
let projects: RulingInput[] = [];

describe('Ruling', () => {
  beforeAll(() => {
    setContext({
      workDir: path.join(os.tmpdir(), 'sonarjs'),
      shouldUseTypeScriptParserForJS: true,
      sonarlint: false,
      bundles: [],
    });

    projects = require('./data/projects')
      // courselit fails for some reason
      .filter(project => project.name === 'angular.js');
    /* .filter(project => !project.name.includes('courselit'))
      .filter(project => !project.name.includes('yaml'))
      .filter(project => !project.name.includes('TypeScript')); */
  });

  it(
    `should run the ruling tests`,
    async () => {
      for (const project of projects) {
        const results = await testProject(jsTsProjectsPath, project);
        writeResults(path.join(jsTsProjectsPath, project.name), project.name, results);
      }
    },
    30 * 60 * 1000,
  );
});

/**
 * Load files and analyze project
 */
async function testProject(baseDir: string, rulingInput: RulingInput) {
  const projectPath = setProjectPath(baseDir, rulingInput.name, rulingInput.folder);
  const exclusions = setExclusions(rulingInput.exclusions, rulingInput.testDir);

  const [jsTsFiles, htmlFiles] = getProjectFiles(rulingInput, projectPath, exclusions);

  const payload: ProjectAnalysisInput = {
    rules: getRules(),
    baseDir: projectPath,
    files: jsTsFiles,
  };

  const jsTsResults = await analyzeProject(payload);
  const htmlResults = await analyzeHtmlFiles(htmlFiles);
  const results = mergeIssues(jsTsResults, htmlResults);

  return results;
}

/**
 * The rules.json file was generated by running the ruling test with `.setDebugLogs(true)`
 * and capturing the `inputRules` parameter from `packages/jsts/src/linter/linters.ts#initializeLinter()`
 */
function getRules() {
  if (rules.length > 0) return rules;
  rules.push(...JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'rules.json'), 'utf8')));
  return rules;
}

function setProjectPath(baseDir: string, name: string, folder?: string) {
  let projectPath;
  if (folder) {
    projectPath = path.join(baseDir, folder);
  } else {
    projectPath = path.join(baseDir, name);
  }
  return projectPath;
}

function setExclusions(exclusions: string, testDir?: string) {
  const DEFAULT_EXCLUSIONS = '**/.*,**/*.d.ts';
  if (exclusions) {
    exclusions += ',' + DEFAULT_EXCLUSIONS;
  } else {
    exclusions = DEFAULT_EXCLUSIONS;
  }
  if (testDir && testDir !== '') {
    exclusions += `,${testDir}/**/*`;
  }
  const exclusionsGlob = stringToGlob(exclusions.split(',').map(pattern => pattern.trim()));
  return exclusionsGlob;

  function stringToGlob(patterns: string[]): Minimatch[] {
    return patterns.map(pattern => new Minimatch(pattern, { nocase: true, matchBase: true }));
  }
}

function getProjectFiles(rulingInput: RulingInput, projectPath: string, exclusions: Minimatch[]) {
  const [jsTsFiles, htmlFiles] = getFiles(projectPath, exclusions);

  if (rulingInput.testDir != null) {
    const testFolder = path.join(projectPath, rulingInput.testDir);
    getFiles(testFolder, exclusions, jsTsFiles, htmlFiles, 'TEST');
  }
  return [jsTsFiles, htmlFiles];
}

async function analyzeHtmlFiles(files: JsTsFiles) {
  const htmlResults = { files: {} };
  for (const [filePath, fileData] of Object.entries(files)) {
    const payload: HtmlAnalysisInput = {
      filePath,
      fileContent: fileData.fileContent,
    };
    try {
      const result = await analyzeHTML(payload);
      htmlResults.files[filePath] = result;
    } catch (err) {
      htmlResults.files[filePath] = { parsingError: { line: err.data.line } };
    }
  }
  return htmlResults;
}

function mergeIssues(...resultsSet: ProjectAnalysisOutput[]) {
  const allResults = { files: {} };
  for (const results of resultsSet) {
    for (const [filePath, fileData] of Object.entries(results.files)) {
      if (!allResults.files[filePath]) {
        allResults.files[filePath] = { issues: [] };
      }
      if (fileData.parsingError) {
        allResults.files[filePath].issues.push(extractParsingError(fileData));
      } else {
        allResults.files[filePath].issues.push(...fileData.issues);
      }
    }
  }
  return allResults;
}

function extractParsingError(fileData: JsTsAnalysisOutput) {
  return {
    ruleId: 'S2260',
    line: fileData.parsingError.line,
    // stub values so we don't have to modify the type
    message: '',
    column: 0,
    secondaryLocations: [],
  };
}

/**
 * Stores in `acc` all the JS/TS files in the given `dir`,
 * ignoring the given `exclusions` and assigning the given `type`
 */
function getFiles(
  dir: string,
  exclusions: Minimatch[],
  jsTsFiles: JsTsFiles = {},
  htmlFiles: JsTsFiles = {},
  type: FileType = 'MAIN',
) {
  const files = fs.readdirSync(dir, { recursive: true }) as string[];
  for (const file of files) {
    const absolutePath = toUnixPath(path.join(dir, file));
    if (!fs.statSync(absolutePath).isFile()) continue;
    const language = findLanguage(absolutePath);
    if (!language) continue;
    const fileContent = fs.readFileSync(absolutePath, 'utf8');
    if (!accept(absolutePath, fileContent)) continue;
    if (isExcluded(file, exclusions)) continue;

    if (absolutePath.endsWith('.html')) {
      htmlFiles[absolutePath] = { fileType: type, fileContent, language };
    } else {
      jsTsFiles[absolutePath] = { fileType: type, fileContent, language };
    }
  }
  return [jsTsFiles, htmlFiles];

  function findLanguage(filePath: string) {
    if (isJsFile(filePath)) {
      return 'js';
    }
    if (isTsFile(filePath)) {
      return 'ts';
    }
  }

  function isJsFile(filePath: string) {
    return jsExts.includes(path.posix.extname(filePath).toLowerCase());
  }

  function isTsFile(filePath: string) {
    return tsExts.includes(path.posix.extname(filePath).toLowerCase());
  }

  function isExcluded(filePath: string, exclusions: Minimatch[]) {
    return exclusions.some(exclusion => exclusion.match(filePath));
  }
}
