syntax = "proto3";
// Generated for @types/estree version: 1.0.5
// Note: this file was manually modified, to reach a working state faster.
// We should eventually adapt the generator once we are happy with the exact structure.
option java_package="org.sonar.plugins.javascript.bridge.protobuf";
option java_multiple_files = true;

message SourceLocation {
  string source = 1;
  Position start = 2;
  Position end = 3;
}
message Position {
  int32 line = 1;
  int32 column = 2;
}

enum NodeType {
  ProgramType = 0;
  ExportAllDeclarationType = 1;
  BigIntLiteralType = 2;
  SimpleLiteralType = 3;
  IdentifierType = 4;
  ExportDefaultDeclarationType = 5;
  YieldExpressionType = 6;
  UpdateExpressionType = 7;
  UnaryExpressionType = 8;
  ThisExpressionType = 9;
  TemplateLiteralType = 10;
  TaggedTemplateExpressionType = 11;
  SequenceExpressionType = 12;
  ObjectExpressionType = 13;
  SpreadElementType = 14;
  PropertyType = 15;
  AssignmentPatternType = 16;
  RestElementType = 17;
  ArrayPatternType = 18;
  ObjectPatternType = 19;
  PrivateIdentifierType = 20;
  NewExpressionType = 21;
  SuperType = 22;
  MetaPropertyType = 23;
  MemberExpressionType = 24;
  LogicalExpressionType = 25;
  ImportExpressionType = 26;
  BlockStatementType = 27;
  ConditionalExpressionType = 28;
  ClassExpressionType = 29;
  ClassBodyType = 30;
  StaticBlockType = 31;
  PropertyDefinitionType = 32;
  MethodDefinitionType = 33;
  ChainExpressionType = 34;
  SimpleCallExpressionType = 35;
  BinaryExpressionType = 36;
  AwaitExpressionType = 37;
  AssignmentExpressionType = 38;
  ArrowFunctionExpressionType = 39;
  ArrayExpressionType = 40;
  MaybeNamedClassDeclarationType = 41;
  MaybeNamedFunctionDeclarationType = 42;
  ExportNamedDeclarationType = 43;
  ExportSpecifierType = 44;
  VariableDeclarationType = 45;
  VariableDeclaratorType = 46;
  ImportDeclarationType = 47;
  ImportNamespaceSpecifierType = 48;
  ImportDefaultSpecifierType = 49;
  ImportSpecifierType = 50;
  ForOfStatementType = 51;
  ForInStatementType = 52;
  ForStatementType = 53;
  DoWhileStatementType = 54;
  WhileStatementType = 55;
  TryStatementType = 56;
  CatchClauseType = 57;
  ThrowStatementType = 58;
  SwitchStatementType = 59;
  SwitchCaseType = 60;
  IfStatementType = 61;
  ContinueStatementType = 62;
  BreakStatementType = 63;
  LabeledStatementType = 64;
  ReturnStatementType = 65;
  WithStatementType = 66;
  DebuggerStatementType = 67;
  EmptyStatementType = 68;
  ExpressionStatementType = 69;
  DirectiveType = 70;
  RegExpLiteralType = 71;
  TemplateElementType = 72;
  FunctionExpressionType = 73;
}
message Node {
  NodeType type = 1;
  SourceLocation loc = 2;
  oneof node {
    Program program = 3;
    ExportAllDeclaration exportAllDeclaration = 4;
    BigIntLiteral bigIntLiteral = 5;
    SimpleLiteral simpleLiteral = 6;
    Identifier identifier = 7;
    ExportDefaultDeclaration exportDefaultDeclaration = 8;
    YieldExpression yieldExpression = 9;
    UpdateExpression updateExpression = 10;
    UnaryExpression unaryExpression = 11;
    ThisExpression thisExpression = 12;
    TemplateLiteral templateLiteral = 13;
    TaggedTemplateExpression taggedTemplateExpression = 14;
    SequenceExpression sequenceExpression = 15;
    ObjectExpression objectExpression = 16;
    SpreadElement spreadElement = 17;
    Property property = 18;
    AssignmentPattern assignmentPattern = 19;
    RestElement restElement = 20;
    ArrayPattern arrayPattern = 21;
    ObjectPattern objectPattern = 22;
    PrivateIdentifier privateIdentifier = 23;
    NewExpression newExpression = 24;
    Super super = 25;
    MetaProperty metaProperty = 26;
    MemberExpression memberExpression = 27;
    LogicalExpression logicalExpression = 28;
    ImportExpression importExpression = 29;
    BlockStatement blockStatement = 30;
    ConditionalExpression conditionalExpression = 31;
    ClassExpression classExpression = 32;
    ClassBody classBody = 33;
    StaticBlock staticBlock = 34;
    PropertyDefinition propertyDefinition = 35;
    MethodDefinition methodDefinition = 36;
    ChainExpression chainExpression = 37;
    SimpleCallExpression simpleCallExpression = 38;
    BinaryExpression binaryExpression = 39;
    AwaitExpression awaitExpression = 40;
    AssignmentExpression assignmentExpression = 41;
    ArrowFunctionExpression arrowFunctionExpression = 42;
    ArrayExpression arrayExpression = 43;
    MaybeNamedClassDeclaration maybeNamedClassDeclaration = 44;
    MaybeNamedFunctionDeclaration maybeNamedFunctionDeclaration = 45;
    ExportNamedDeclaration exportNamedDeclaration = 46;
    ExportSpecifier exportSpecifier = 47;
    VariableDeclaration variableDeclaration = 48;
    VariableDeclarator variableDeclarator = 49;
    ImportDeclaration importDeclaration = 50;
    ImportNamespaceSpecifier importNamespaceSpecifier = 51;
    ImportDefaultSpecifier importDefaultSpecifier = 52;
    ImportSpecifier importSpecifier = 53;
    ForOfStatement forOfStatement = 54;
    ForInStatement forInStatement = 55;
    ForStatement forStatement = 56;
    DoWhileStatement doWhileStatement = 57;
    WhileStatement whileStatement = 58;
    TryStatement tryStatement = 59;
    CatchClause catchClause = 60;
    ThrowStatement throwStatement = 61;
    SwitchStatement switchStatement = 62;
    SwitchCase switchCase = 63;
    IfStatement ifStatement = 64;
    ContinueStatement continueStatement = 65;
    BreakStatement breakStatement = 66;
    LabeledStatement labeledStatement = 67;
    ReturnStatement returnStatement = 68;
    WithStatement withStatement = 69;
    DebuggerStatement debuggerStatement = 70;
    EmptyStatement emptyStatement = 71;
    ExpressionStatement expressionStatement = 72;
    Directive directive = 73;
    RegExpLiteral regExpLiteral = 74;
    TemplateElement templateElement = 75;
    FunctionExpression functionExpression = 76;
  }
}
message Program {
  string sourceType = 1;
  repeated Node body = 2;
}
message ExportAllDeclaration {
  Node exported = 1;
  Node source = 2;
}
message BigIntLiteral {
  int32 value = 1;
  string bigint = 2;
  string raw = 3;
}
message SimpleLiteral {
  oneof value {
    string value_string = 1;
    bool value_boolean = 2;
    int32 value_number = 3;
  }
  string raw = 4;
}
message Identifier {
  string name = 1;
}
message ExportDefaultDeclaration {
  Node declaration = 1;
}
message YieldExpression {
  Node argument = 1;
  bool delegate = 2;
}
message UpdateExpression {
  string operator = 1;
  Node argument = 2;
  bool prefix = 3;
}
message UnaryExpression {
  string operator = 1;
  bool prefix = 2;
  Node argument = 3;
}
message ThisExpression {
}
message TemplateLiteral {
  repeated Node quasis = 1;
  repeated Node expressions = 2;
}
message TaggedTemplateExpression {
  Node tag = 1;
  Node quasi = 2;
}
message SequenceExpression {
  repeated Node expressions = 1;
}
message ObjectExpression {
  repeated Node properties = 1;
}
message SpreadElement {
  Node argument = 1;
}
message Property {
  Node key = 1;
  Node value = 2;
  string kind = 3;
  bool method = 4;
  bool shorthand = 5;
  bool computed = 6;
}
message AssignmentPattern {
  Node left = 1;
  Node right = 2;
}
message RestElement {
  Node argument = 1;
}
message ArrayPattern {
  repeated Node elements = 1;
}
message ObjectPattern {
  repeated Node properties = 1;
}
message PrivateIdentifier {
  string name = 1;
}
message NewExpression {
  Node callee = 1;
  repeated Node arguments = 2;
}
message Super {
}
message MetaProperty {
  Node meta = 1;
  Node property = 2;
}
message MemberExpression {
  Node object = 1;
  Node property = 2;
  bool computed = 3;
  bool optional = 4;
}
message LogicalExpression {
  Node operator = 1;
  Node left = 2;
  Node right = 3;
}
message ImportExpression {
  Node source = 1;
}
message BlockStatement {
  repeated Node body = 1;
}
message ConditionalExpression {
  Node test = 1;
  Node alternate = 2;
  Node consequent = 3;
}
message ClassExpression {
  Node id = 1;
  Node superClass = 2;
  Node body = 3;
}
message ClassBody {
  repeated Node body = 1;
}
message StaticBlock {
}
message PropertyDefinition {
  Node key = 1;
  Node value = 2;
  bool computed = 3;
  bool static = 4;
}
message MethodDefinition {
  Node key = 1;
  Node value = 2;
  string kind = 3;
  bool computed = 4;
  bool static = 5;
}
message ChainExpression {
  Node expression = 1;
}
message SimpleCallExpression {
  bool optional = 1;
  Node callee = 2;
  repeated Node arguments = 3;
}
message BinaryExpression {
  string operator = 1;
  Node left = 2;
  Node right = 3;
}
message AwaitExpression {
  Node argument = 1;
}
message AssignmentExpression {
  string operator = 1;
  Node left = 2;
  Node right = 3;
}
message ArrowFunctionExpression {
  bool expression = 1;
  Node body = 2;
  repeated Node params = 3;
  bool generator = 4;
  bool async = 5;
}
message ArrayExpression {
  repeated Node elements = 1;
}
message MaybeNamedClassDeclaration {
  Node id = 1;
  Node superClass = 2;
  Node body = 3;
}
message MaybeNamedFunctionDeclaration {
  Node id = 1;
  Node body = 2;
  repeated Node params = 3;
  bool generator = 4;
  bool async = 5;
}
message ExportNamedDeclaration {
  Node declaration = 1;
  repeated Node specifiers = 2;
  Node source = 3;
}
message ExportSpecifier {
  Node exported = 1;
  Node local = 2;
}
message VariableDeclaration {
  repeated Node declarations = 1;
  string kind = 2;
}
message VariableDeclarator {
  Node id = 1;
  Node init = 2;
}
message ImportDeclaration {
  repeated Node specifiers = 1;
  Node source = 2;
}
message ImportNamespaceSpecifier {
  Node local = 1;
}
message ImportDefaultSpecifier {
  Node local = 1;
}
message ImportSpecifier {
  Node imported = 1;
  Node local = 2;
}
message ForOfStatement {
  bool await = 1;
  Node left = 2;
  Node right = 3;
  Node body = 4;
}
message ForInStatement {
  Node left = 1;
  Node right = 2;
  Node body = 3;
}
message ForStatement {
  Node init = 1;
  Node test = 2;
  Node update = 3;
  Node body = 4;
}
message DoWhileStatement {
  Node body = 1;
  Node test = 2;
}
message WhileStatement {
  Node test = 1;
  Node body = 2;
}
message TryStatement {
  Node block = 1;
  Node handler = 2;
  Node finalizer = 3;
}
message CatchClause {
  Node param = 1;
  Node body = 2;
}
message ThrowStatement {
  Node argument = 1;
}
message SwitchStatement {
  Node discriminant = 1;
  repeated Node cases = 2;
}
message SwitchCase {
  Node test = 1;
  repeated Node consequent = 2;
}
message IfStatement {
  Node test = 1;
  Node consequent = 2;
  Node alternate = 3;
}
message ContinueStatement {
  Node label = 1;
}
message BreakStatement {
  Node label = 1;
}
message LabeledStatement {
  Node label = 1;
  Node body = 2;
}
message ReturnStatement {
  Node argument = 1;
}
message WithStatement {
  Node object = 1;
  Node body = 2;
}
message DebuggerStatement {
}
message EmptyStatement {
}
message ExpressionStatement {
  Node expression = 1;
}
message Directive {
  Node expression = 1;
  string directive = 2;
}
message RegExpLiteral {
  string pattern = 1;
  string flags = 2;
  string raw = 3;
}
message TemplateElement {
  bool tail = 1;
  string cooked = 2;
  string raw = 3;
}

message FunctionExpression {
  Node id = 1;
  Node body = 2;
  repeated Node params = 3;
  bool generator = 4;
  bool async = 5;
}
