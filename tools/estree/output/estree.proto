syntax = "proto3";
// Generated for @types/estree version: 1.0.5
option java_package="org.sonar.plugins.javascript.bridge.protobuf";
option java_multiple_files = true;

message SourceLocation {
  string source = 0;
  Position start = 1;
  Position end = 2;
}
message Position {
  int32 line = 0;
  int32 end = 1;
}

enum NodeType {
  Program = 0;
  ExportAllDeclaration = 1;
  BigIntLiteral = 2;
  SimpleLiteral = 3;
  Identifier = 4;
  ExportDefaultDeclaration = 5;
  YieldExpression = 6;
  UpdateExpression = 7;
  UnaryExpression = 8;
  ThisExpression = 9;
  TemplateLiteral = 10;
  TaggedTemplateExpression = 11;
  SequenceExpression = 12;
  ObjectExpression = 13;
  SpreadElement = 14;
  Property = 15;
  AssignmentPattern = 16;
  RestElement = 17;
  ArrayPattern = 18;
  ObjectPattern = 19;
  PrivateIdentifier = 20;
  NewExpression = 21;
  Super = 22;
  MetaProperty = 23;
  MemberExpression = 24;
  LogicalExpression = 25;
  ImportExpression = 26;
  BlockStatement = 27;
  ConditionalExpression = 28;
  ClassExpression = 29;
  ClassBody = 30;
  StaticBlock = 31;
  PropertyDefinition = 32;
  MethodDefinition = 33;
  ChainExpression = 34;
  SimpleCallExpression = 35;
  BinaryExpression = 36;
  AwaitExpression = 37;
  AssignmentExpression = 38;
  ArrowFunctionExpression = 39;
  ArrayExpression = 40;
  MaybeNamedClassDeclaration = 41;
  MaybeNamedFunctionDeclaration = 42;
  ExportNamedDeclaration = 43;
  ExportSpecifier = 44;
  VariableDeclaration = 45;
  VariableDeclarator = 46;
  ImportDeclaration = 47;
  ImportNamespaceSpecifier = 48;
  ImportDefaultSpecifier = 49;
  ImportSpecifier = 50;
  ForOfStatement = 51;
  ForInStatement = 52;
  ForStatement = 53;
  DoWhileStatement = 54;
  WhileStatement = 55;
  TryStatement = 56;
  CatchClause = 57;
  ThrowStatement = 58;
  SwitchStatement = 59;
  SwitchCase = 60;
  IfStatement = 61;
  ContinueStatement = 62;
  BreakStatement = 63;
  LabeledStatement = 64;
  ReturnStatement = 65;
  WithStatement = 66;
  DebuggerStatement = 67;
  EmptyStatement = 68;
  ExpressionStatement = 69;
  Directive = 70;
  RegExpLiteral = 71;
  TemplateElement = 72;
  FunctionExpressionType = 73;
}
message Node {
  NodeType type = 0;
  SourceLocation loc = 1;
  oneof node {
    Program program = 2;
    ExportAllDeclaration exportAllDeclaration = 3;
    BigIntLiteral bigIntLiteral = 4;
    SimpleLiteral simpleLiteral = 5;
    Identifier identifier = 6;
    ExportDefaultDeclaration exportDefaultDeclaration = 7;
    YieldExpression yieldExpression = 8;
    UpdateExpression updateExpression = 9;
    UnaryExpression unaryExpression = 10;
    ThisExpression thisExpression = 11;
    TemplateLiteral templateLiteral = 12;
    TaggedTemplateExpression taggedTemplateExpression = 13;
    SequenceExpression sequenceExpression = 14;
    ObjectExpression objectExpression = 15;
    SpreadElement spreadElement = 16;
    Property property = 17;
    AssignmentPattern assignmentPattern = 18;
    RestElement restElement = 19;
    ArrayPattern arrayPattern = 20;
    ObjectPattern objectPattern = 21;
    PrivateIdentifier privateIdentifier = 22;
    NewExpression newExpression = 23;
    Super super = 24;
    MetaProperty metaProperty = 25;
    MemberExpression memberExpression = 26;
    LogicalExpression logicalExpression = 27;
    ImportExpression importExpression = 28;
    BlockStatement blockStatement = 29;
    ConditionalExpression conditionalExpression = 30;
    ClassExpression classExpression = 31;
    ClassBody classBody = 32;
    StaticBlock staticBlock = 33;
    PropertyDefinition propertyDefinition = 34;
    MethodDefinition methodDefinition = 35;
    ChainExpression chainExpression = 36;
    SimpleCallExpression simpleCallExpression = 37;
    BinaryExpression binaryExpression = 38;
    AwaitExpression awaitExpression = 39;
    AssignmentExpression assignmentExpression = 40;
    ArrowFunctionExpression arrowFunctionExpression = 41;
    ArrayExpression arrayExpression = 42;
    MaybeNamedClassDeclaration maybeNamedClassDeclaration = 43;
    MaybeNamedFunctionDeclaration maybeNamedFunctionDeclaration = 44;
    ExportNamedDeclaration exportNamedDeclaration = 45;
    ExportSpecifier exportSpecifier = 46;
    VariableDeclaration variableDeclaration = 47;
    VariableDeclarator variableDeclarator = 48;
    ImportDeclaration importDeclaration = 49;
    ImportNamespaceSpecifier importNamespaceSpecifier = 50;
    ImportDefaultSpecifier importDefaultSpecifier = 51;
    ImportSpecifier importSpecifier = 52;
    ForOfStatement forOfStatement = 53;
    ForInStatement forInStatement = 54;
    ForStatement forStatement = 55;
    DoWhileStatement doWhileStatement = 56;
    WhileStatement whileStatement = 57;
    TryStatement tryStatement = 58;
    CatchClause catchClause = 59;
    ThrowStatement throwStatement = 60;
    SwitchStatement switchStatement = 61;
    SwitchCase switchCase = 62;
    IfStatement ifStatement = 63;
    ContinueStatement continueStatement = 64;
    BreakStatement breakStatement = 65;
    LabeledStatement labeledStatement = 66;
    ReturnStatement returnStatement = 67;
    WithStatement withStatement = 68;
    DebuggerStatement debuggerStatement = 69;
    EmptyStatement emptyStatement = 70;
    ExpressionStatement expressionStatement = 71;
    Directive directive = 72;
    RegExpLiteral regExpLiteral = 73;
    TemplateElement templateElement = 74;
    FunctionExpression functionExpression = 75;
  }
}
message Program {
  string sourceType = 0;
  repeated Node body = 1;
}
message ExportAllDeclaration {
  Node exported = 0;
  Node source = 1;
}
message BigIntLiteral {
  int32 value = 0;
  string bigint = 1;
  string raw = 2;
}
message SimpleLiteral {
  Node value = 0;
  string raw = 1;
}
message Identifier {
  string name = 0;
}
message ExportDefaultDeclaration {
  Node declaration = 0;
}
message YieldExpression {
  Node argument = 0;
  bool delegate = 1;
}
message UpdateExpression {
  string operator = 0;
  Node argument = 1;
  bool prefix = 2;
}
message UnaryExpression {
  string operator = 0;
  bool prefix = 1;
  Node argument = 2;
}
message ThisExpression {
}
message TemplateLiteral {
  repeated Node quasis = 0;
  repeated Node expressions = 1;
}
message TaggedTemplateExpression {
  Node tag = 0;
  Node quasi = 1;
}
message SequenceExpression {
  repeated Node expressions = 0;
}
message ObjectExpression {
  repeated Node properties = 0;
}
message SpreadElement {
  Node argument = 0;
}
message Property {
  Node key = 0;
  Node value = 1;
  string kind = 2;
  bool method = 3;
  bool shorthand = 4;
  bool computed = 5;
}
message AssignmentPattern {
  Node left = 0;
  Node right = 1;
}
message RestElement {
  Node argument = 0;
}
message ArrayPattern {
  repeated Node elements = 0;
}
message ObjectPattern {
  repeated Node properties = 0;
}
message PrivateIdentifier {
  string name = 0;
}
message NewExpression {
  Node callee = 0;
  repeated Node arguments = 1;
}
message Super {
}
message MetaProperty {
  Node meta = 0;
  Node property = 1;
}
message MemberExpression {
  Node object = 0;
  Node property = 1;
  bool computed = 2;
  bool optional = 3;
}
message LogicalExpression {
  Node operator = 0;
  Node left = 1;
  Node right = 2;
}
message ImportExpression {
  Node source = 0;
}
message BlockStatement {
  repeated Node body = 0;
}
message ConditionalExpression {
  Node test = 0;
  Node alternate = 1;
  Node consequent = 2;
}
message ClassExpression {
  Node id = 0;
  Node superClass = 1;
  Node body = 2;
}
message ClassBody {
  repeated Node body = 0;
}
message StaticBlock {
}
message PropertyDefinition {
  Node key = 0;
  Node value = 1;
  bool computed = 2;
  bool static = 3;
}
message MethodDefinition {
  Node key = 0;
  Node value = 1;
  string kind = 2;
  bool computed = 3;
  bool static = 4;
}
message ChainExpression {
  Node expression = 0;
}
message SimpleCallExpression {
  bool optional = 0;
  Node callee = 1;
  repeated Node arguments = 2;
}
message BinaryExpression {
  string operator = 0;
  Node left = 1;
  Node right = 2;
}
message AwaitExpression {
  Node argument = 0;
}
message AssignmentExpression {
  string operator = 0;
  Node left = 1;
  Node right = 2;
}
message ArrowFunctionExpression {
  bool expression = 0;
  Node body = 1;
  repeated Node params = 2;
  bool generator = 3;
  bool async = 4;
}
message ArrayExpression {
  repeated Node elements = 0;
}
message MaybeNamedClassDeclaration {
  Node id = 0;
  Node superClass = 1;
  Node body = 2;
}
message MaybeNamedFunctionDeclaration {
  Node id = 0;
  Node body = 1;
  repeated Node params = 2;
  bool generator = 3;
  bool async = 4;
}
message ExportNamedDeclaration {
  Node declaration = 0;
  repeated Node specifiers = 1;
  Node source = 2;
}
message ExportSpecifier {
  Node exported = 0;
  Node local = 1;
}
message VariableDeclaration {
  repeated Node declarations = 0;
  string kind = 1;
}
message VariableDeclarator {
  Node id = 0;
  Node init = 1;
}
message ImportDeclaration {
  repeated Node specifiers = 0;
  Node source = 1;
}
message ImportNamespaceSpecifier {
  Node local = 0;
}
message ImportDefaultSpecifier {
  Node local = 0;
}
message ImportSpecifier {
  Node imported = 0;
  Node local = 1;
}
message ForOfStatement {
  bool await = 0;
  Node left = 1;
  Node right = 2;
  Node body = 3;
}
message ForInStatement {
  Node left = 0;
  Node right = 1;
  Node body = 2;
}
message ForStatement {
  Node init = 0;
  Node test = 1;
  Node update = 2;
  Node body = 3;
}
message DoWhileStatement {
  Node body = 0;
  Node test = 1;
}
message WhileStatement {
  Node test = 0;
  Node body = 1;
}
message TryStatement {
  Node block = 0;
  Node handler = 1;
  Node finalizer = 2;
}
message CatchClause {
  Node param = 0;
  Node body = 1;
}
message ThrowStatement {
  Node argument = 0;
}
message SwitchStatement {
  Node discriminant = 0;
  repeated Node cases = 1;
}
message SwitchCase {
  Node test = 0;
  repeated Node consequent = 1;
}
message IfStatement {
  Node test = 0;
  Node consequent = 1;
  Node alternate = 2;
}
message ContinueStatement {
  Node label = 0;
}
message BreakStatement {
  Node label = 0;
}
message LabeledStatement {
  Node label = 0;
  Node body = 1;
}
message ReturnStatement {
  Node argument = 0;
}
message WithStatement {
  Node object = 0;
  Node body = 1;
}
message DebuggerStatement {
}
message EmptyStatement {
}
message ExpressionStatement {
  Node expression = 0;
}
message Directive {
  Node expression = 0;
  string directive = 1;
}
message RegExpLiteral {
  string pattern = 0;
  string flags = 1;
  string raw = 2;
}
message TemplateElement {
  bool tail = 0;
  string cooked = 1;
  string raw = 2;
}

message FunctionExpression {
  Node id = 0;
  Node body = 1;
  repeated Node params = 2;
  bool generator = 3;
  bool async = 4;
}
