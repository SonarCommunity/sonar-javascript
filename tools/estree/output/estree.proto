syntax = "proto3";
// Generated for @types/estree version: 1.0.5

message SourceLocation {
  string source = 1;
  Position start = 2;
  Position end = 3;
}
message Position {
  int32 line = 1;
  int32 end = 2;
}

enum NodeType {
  Program = 1;
  ExportAllDeclaration = 2;
  BigIntLiteral = 3;
  SimpleLiteral = 4;
  Identifier = 5;
  ExportDefaultDeclaration = 6;
  YieldExpression = 7;
  UpdateExpression = 8;
  UnaryExpression = 9;
  ThisExpression = 10;
  TemplateLiteral = 11;
  TaggedTemplateExpression = 12;
  SequenceExpression = 13;
  ObjectExpression = 14;
  SpreadElement = 15;
  Property = 16;
  AssignmentPattern = 17;
  RestElement = 18;
  ArrayPattern = 19;
  ObjectPattern = 20;
  PrivateIdentifier = 21;
  NewExpression = 22;
  Super = 23;
  MetaProperty = 24;
  MemberExpression = 25;
  LogicalExpression = 26;
  ImportExpression = 27;
  BlockStatement = 28;
  ConditionalExpression = 29;
  ClassExpression = 30;
  ClassBody = 31;
  StaticBlock = 32;
  PropertyDefinition = 33;
  MethodDefinition = 34;
  ChainExpression = 35;
  SimpleCallExpression = 36;
  BinaryExpression = 37;
  AwaitExpression = 38;
  AssignmentExpression = 39;
  ArrowFunctionExpression = 40;
  ArrayExpression = 41;
  MaybeNamedClassDeclaration = 42;
  MaybeNamedFunctionDeclaration = 43;
  ExportNamedDeclaration = 44;
  ExportSpecifier = 45;
  VariableDeclaration = 46;
  VariableDeclarator = 47;
  ImportDeclaration = 48;
  ImportNamespaceSpecifier = 49;
  ImportDefaultSpecifier = 50;
  ImportSpecifier = 51;
  ForOfStatement = 52;
  ForInStatement = 53;
  ForStatement = 54;
  DoWhileStatement = 55;
  WhileStatement = 56;
  TryStatement = 57;
  CatchClause = 58;
  ThrowStatement = 59;
  SwitchStatement = 60;
  SwitchCase = 61;
  IfStatement = 62;
  ContinueStatement = 63;
  BreakStatement = 64;
  LabeledStatement = 65;
  ReturnStatement = 66;
  WithStatement = 67;
  DebuggerStatement = 68;
  EmptyStatement = 69;
  ExpressionStatement = 70;
  Directive = 71;
  RegExpLiteral = 72;
  TemplateElement = 73;
}
message Node {
  NodeType type = 1;
  SourceLocation loc = 2;
  oneof node {
    Program program = 3;
    ExportAllDeclaration exportAllDeclaration = 4;
    BigIntLiteral bigIntLiteral = 5;
    SimpleLiteral simpleLiteral = 6;
    Identifier identifier = 7;
    ExportDefaultDeclaration exportDefaultDeclaration = 8;
    YieldExpression yieldExpression = 9;
    UpdateExpression updateExpression = 10;
    UnaryExpression unaryExpression = 11;
    ThisExpression thisExpression = 12;
    TemplateLiteral templateLiteral = 13;
    TaggedTemplateExpression taggedTemplateExpression = 14;
    SequenceExpression sequenceExpression = 15;
    ObjectExpression objectExpression = 16;
    SpreadElement spreadElement = 17;
    Property property = 18;
    AssignmentPattern assignmentPattern = 19;
    RestElement restElement = 20;
    ArrayPattern arrayPattern = 21;
    ObjectPattern objectPattern = 22;
    PrivateIdentifier privateIdentifier = 23;
    NewExpression newExpression = 24;
    Super super = 25;
    MetaProperty metaProperty = 26;
    MemberExpression memberExpression = 27;
    LogicalExpression logicalExpression = 28;
    ImportExpression importExpression = 29;
    BlockStatement blockStatement = 30;
    ConditionalExpression conditionalExpression = 31;
    ClassExpression classExpression = 32;
    ClassBody classBody = 33;
    StaticBlock staticBlock = 34;
    PropertyDefinition propertyDefinition = 35;
    MethodDefinition methodDefinition = 36;
    ChainExpression chainExpression = 37;
    SimpleCallExpression simpleCallExpression = 38;
    BinaryExpression binaryExpression = 39;
    AwaitExpression awaitExpression = 40;
    AssignmentExpression assignmentExpression = 41;
    ArrowFunctionExpression arrowFunctionExpression = 42;
    ArrayExpression arrayExpression = 43;
    MaybeNamedClassDeclaration maybeNamedClassDeclaration = 44;
    MaybeNamedFunctionDeclaration maybeNamedFunctionDeclaration = 45;
    ExportNamedDeclaration exportNamedDeclaration = 46;
    ExportSpecifier exportSpecifier = 47;
    VariableDeclaration variableDeclaration = 48;
    VariableDeclarator variableDeclarator = 49;
    ImportDeclaration importDeclaration = 50;
    ImportNamespaceSpecifier importNamespaceSpecifier = 51;
    ImportDefaultSpecifier importDefaultSpecifier = 52;
    ImportSpecifier importSpecifier = 53;
    ForOfStatement forOfStatement = 54;
    ForInStatement forInStatement = 55;
    ForStatement forStatement = 56;
    DoWhileStatement doWhileStatement = 57;
    WhileStatement whileStatement = 58;
    TryStatement tryStatement = 59;
    CatchClause catchClause = 60;
    ThrowStatement throwStatement = 61;
    SwitchStatement switchStatement = 62;
    SwitchCase switchCase = 63;
    IfStatement ifStatement = 64;
    ContinueStatement continueStatement = 65;
    BreakStatement breakStatement = 66;
    LabeledStatement labeledStatement = 67;
    ReturnStatement returnStatement = 68;
    WithStatement withStatement = 69;
    DebuggerStatement debuggerStatement = 70;
    EmptyStatement emptyStatement = 71;
    ExpressionStatement expressionStatement = 72;
    Directive directive = 73;
    RegExpLiteral regExpLiteral = 74;
    TemplateElement templateElement = 75;
  }
}
message Program {
  string sourceType = 1;
  repeated Node body = 2;
}
message ExportAllDeclaration {
  Node exported = 1;
  Node source = 2;
}
message BigIntLiteral {
  int32 value = 1;
  string bigint = 2;
  string raw = 3;
}
message SimpleLiteral {
  oneof value {
    string value_string = 1;
    bool value_boolean = 2;
    int32 value_number = 3;
  }
  string raw = 4;
}
message Identifier {
  string name = 1;
}
message ExportDefaultDeclaration {
  Node declaration = 1;
}
message YieldExpression {
  Node argument = 1;
  bool delegate = 2;
}
message UpdateExpression {
  string operator = 1;
  Node argument = 2;
  bool prefix = 3;
}
message UnaryExpression {
  string operator = 1;
  bool prefix = 2;
  Node argument = 3;
}
message ThisExpression {
}
message TemplateLiteral {
  repeated Node quasis = 1;
  repeated Node expressions = 2;
}
message TaggedTemplateExpression {
  Node tag = 1;
  Node quasi = 2;
}
message SequenceExpression {
  repeated Node expressions = 1;
}
message ObjectExpression {
  repeated Node properties = 1;
}
message SpreadElement {
  Node argument = 1;
}
message Property {
  Node key = 1;
  Node value = 2;
  string kind = 3;
  bool method = 4;
  bool shorthand = 5;
  bool computed = 6;
}
message AssignmentPattern {
  Node left = 1;
  Node right = 2;
}
message RestElement {
  Node argument = 1;
}
message ArrayPattern {
  repeated Node elements = 1;
}
message ObjectPattern {
  repeated Node properties = 1;
}
message PrivateIdentifier {
  string name = 1;
}
message NewExpression {
  Node callee = 1;
  repeated Node arguments = 2;
}
message Super {
}
message MetaProperty {
  Node meta = 1;
  Node property = 2;
}
message MemberExpression {
  Node object = 1;
  Node property = 2;
  bool computed = 3;
  bool optional = 4;
}
message LogicalExpression {
  Node operator = 1;
  Node left = 2;
  Node right = 3;
}
message ImportExpression {
  Node source = 1;
}
message BlockStatement {
  repeated Node body = 1;
}
message ConditionalExpression {
  Node test = 1;
  Node alternate = 2;
  Node consequent = 3;
}
message ClassExpression {
  Node id = 1;
  Node superClass = 2;
  Node body = 3;
}
message ClassBody {
  repeated Node body = 1;
}
message StaticBlock {
}
message PropertyDefinition {
  Node key = 1;
  Node value = 2;
  bool computed = 3;
  bool static = 4;
}
message MethodDefinition {
  Node key = 1;
  Node value = 2;
  string kind = 3;
  bool computed = 4;
  bool static = 5;
}
message ChainExpression {
  Node expression = 1;
}
message SimpleCallExpression {
  bool optional = 1;
  Node callee = 2;
  repeated Node arguments = 3;
}
message BinaryExpression {
  string operator = 1;
  Node left = 2;
  Node right = 3;
}
message AwaitExpression {
  Node argument = 1;
}
message AssignmentExpression {
  string operator = 1;
  Node left = 2;
  Node right = 3;
}
message ArrowFunctionExpression {
  bool expression = 1;
  Node body = 2;
  repeated Node params = 3;
  bool generator = 4;
  bool async = 5;
}
message ArrayExpression {
  repeated Node elements = 1;
}
message MaybeNamedClassDeclaration {
  Node id = 1;
  Node superClass = 2;
  Node body = 3;
}
message MaybeNamedFunctionDeclaration {
  Node id = 1;
  Node body = 2;
  repeated Node params = 3;
  bool generator = 4;
  bool async = 5;
}
message ExportNamedDeclaration {
  Node declaration = 1;
  repeated Node specifiers = 2;
  Node source = 3;
}
message ExportSpecifier {
  Node exported = 1;
  Node local = 2;
}
message VariableDeclaration {
  repeated Node declarations = 1;
  string kind = 2;
}
message VariableDeclarator {
  Node id = 1;
  Node init = 2;
}
message ImportDeclaration {
  repeated Node specifiers = 1;
  Node source = 2;
}
message ImportNamespaceSpecifier {
  Node local = 1;
}
message ImportDefaultSpecifier {
  Node local = 1;
}
message ImportSpecifier {
  Node imported = 1;
  Node local = 2;
}
message ForOfStatement {
  bool await = 1;
  Node left = 2;
  Node right = 3;
  Node body = 4;
}
message ForInStatement {
  Node left = 1;
  Node right = 2;
  Node body = 3;
}
message ForStatement {
  Node init = 1;
  Node test = 2;
  Node update = 3;
  Node body = 4;
}
message DoWhileStatement {
  Node body = 1;
  Node test = 2;
}
message WhileStatement {
  Node test = 1;
  Node body = 2;
}
message TryStatement {
  Node block = 1;
  Node handler = 2;
  Node finalizer = 3;
}
message CatchClause {
  Node param = 1;
  Node body = 2;
}
message ThrowStatement {
  Node argument = 1;
}
message SwitchStatement {
  Node discriminant = 1;
  repeated Node cases = 2;
}
message SwitchCase {
  Node test = 1;
  repeated Node consequent = 2;
}
message IfStatement {
  Node test = 1;
  Node consequent = 2;
  Node alternate = 3;
}
message ContinueStatement {
  Node label = 1;
}
message BreakStatement {
  Node label = 1;
}
message LabeledStatement {
  Node label = 1;
  Node body = 2;
}
message ReturnStatement {
  Node argument = 1;
}
message WithStatement {
  Node object = 1;
  Node body = 2;
}
message DebuggerStatement {
}
message EmptyStatement {
}
message ExpressionStatement {
  Node expression = 1;
}
message Directive {
  Node expression = 1;
  string directive = 2;
}
message RegExpLiteral {
  string pattern = 1;
  string flags = 2;
  string raw = 3;
}
message TemplateElement {
  bool tail = 1;
  string cooked = 2;
  string raw = 3;
}
