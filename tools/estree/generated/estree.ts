/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.0
 * source: estree.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf';
export enum NodeType {
  ProgramType = 0,
  ExportAllDeclarationType = 1,
  BigIntLiteralType = 2,
  SimpleLiteralType = 3,
  IdentifierType = 4,
  ExportDefaultDeclarationType = 5,
  YieldExpressionType = 6,
  UpdateExpressionType = 7,
  UnaryExpressionType = 8,
  ThisExpressionType = 9,
  TemplateLiteralType = 10,
  TaggedTemplateExpressionType = 11,
  SequenceExpressionType = 12,
  ObjectExpressionType = 13,
  SpreadElementType = 14,
  PropertyType = 15,
  AssignmentPatternType = 16,
  RestElementType = 17,
  ArrayPatternType = 18,
  ObjectPatternType = 19,
  PrivateIdentifierType = 20,
  NewExpressionType = 21,
  SuperType = 22,
  MetaPropertyType = 23,
  MemberExpressionType = 24,
  LogicalExpressionType = 25,
  ImportExpressionType = 26,
  BlockStatementType = 27,
  ConditionalExpressionType = 28,
  ClassExpressionType = 29,
  ClassBodyType = 30,
  StaticBlockType = 31,
  PropertyDefinitionType = 32,
  MethodDefinitionType = 33,
  ChainExpressionType = 34,
  SimpleCallExpressionType = 35,
  BinaryExpressionType = 36,
  AwaitExpressionType = 37,
  AssignmentExpressionType = 38,
  ArrowFunctionExpressionType = 39,
  ArrayExpressionType = 40,
  MaybeNamedClassDeclarationType = 41,
  MaybeNamedFunctionDeclarationType = 42,
  ExportNamedDeclarationType = 43,
  ExportSpecifierType = 44,
  VariableDeclarationType = 45,
  VariableDeclaratorType = 46,
  ImportDeclarationType = 47,
  ImportNamespaceSpecifierType = 48,
  ImportDefaultSpecifierType = 49,
  ImportSpecifierType = 50,
  ForOfStatementType = 51,
  ForInStatementType = 52,
  ForStatementType = 53,
  DoWhileStatementType = 54,
  WhileStatementType = 55,
  TryStatementType = 56,
  CatchClauseType = 57,
  ThrowStatementType = 58,
  SwitchStatementType = 59,
  SwitchCaseType = 60,
  IfStatementType = 61,
  ContinueStatementType = 62,
  BreakStatementType = 63,
  LabeledStatementType = 64,
  ReturnStatementType = 65,
  WithStatementType = 66,
  DebuggerStatementType = 67,
  EmptyStatementType = 68,
  ExpressionStatementType = 69,
  DirectiveType = 70,
  RegExpLiteralType = 71,
  TemplateElementType = 72,
  FunctionExpressionType = 73,
}
export class SourceLocation extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          source?: string;
          start?: Position;
          end?: Position;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('source' in data && data.source != undefined) {
        this.source = data.source;
      }
      if ('start' in data && data.start != undefined) {
        this.start = data.start;
      }
      if ('end' in data && data.end != undefined) {
        this.end = data.end;
      }
    }
  }
  get source() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set source(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get start() {
    return pb_1.Message.getWrapperField(this, Position, 2) as Position;
  }
  set start(value: Position) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_start() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get end() {
    return pb_1.Message.getWrapperField(this, Position, 3) as Position;
  }
  set end(value: Position) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_end() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    source?: string;
    start?: ReturnType<typeof Position.prototype.toObject>;
    end?: ReturnType<typeof Position.prototype.toObject>;
  }): SourceLocation {
    const message = new SourceLocation({});
    if (data.source != null) {
      message.source = data.source;
    }
    if (data.start != null) {
      message.start = Position.fromObject(data.start);
    }
    if (data.end != null) {
      message.end = Position.fromObject(data.end);
    }
    return message;
  }
  toObject() {
    const data: {
      source?: string;
      start?: ReturnType<typeof Position.prototype.toObject>;
      end?: ReturnType<typeof Position.prototype.toObject>;
    } = {};
    if (this.source != null) {
      data.source = this.source;
    }
    if (this.start != null) {
      data.start = this.start.toObject();
    }
    if (this.end != null) {
      data.end = this.end.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.source.length) writer.writeString(1, this.source);
    if (this.has_start) writer.writeMessage(2, this.start, () => this.start.serialize(writer));
    if (this.has_end) writer.writeMessage(3, this.end, () => this.end.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SourceLocation {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SourceLocation();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.source = reader.readString();
          break;
        case 2:
          reader.readMessage(message.start, () => (message.start = Position.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.end, () => (message.end = Position.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SourceLocation {
    return SourceLocation.deserialize(bytes);
  }
}
export class Position extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          line?: number;
          end?: number;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('line' in data && data.line != undefined) {
        this.line = data.line;
      }
      if ('end' in data && data.end != undefined) {
        this.end = data.end;
      }
    }
  }
  get line() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set line(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get end() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
  }
  set end(value: number) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: { line?: number; end?: number }): Position {
    const message = new Position({});
    if (data.line != null) {
      message.line = data.line;
    }
    if (data.end != null) {
      message.end = data.end;
    }
    return message;
  }
  toObject() {
    const data: {
      line?: number;
      end?: number;
    } = {};
    if (this.line != null) {
      data.line = this.line;
    }
    if (this.end != null) {
      data.end = this.end;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.line != 0) writer.writeInt32(1, this.line);
    if (this.end != 0) writer.writeInt32(2, this.end);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Position {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Position();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.line = reader.readInt32();
          break;
        case 2:
          message.end = reader.readInt32();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Position {
    return Position.deserialize(bytes);
  }
}
export class Node extends pb_1.Message {
  #one_of_decls: number[][] = [
    [
      3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
      28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
      51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
      74, 75, 76,
    ],
  ];
  constructor(
    data?:
      | any[]
      | ({
          type?: NodeType;
          loc?: SourceLocation;
        } & (
          | {
              program?: Program;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: ExportAllDeclaration;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: BigIntLiteral;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: SimpleLiteral;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: Identifier;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: ExportDefaultDeclaration;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: YieldExpression;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: UpdateExpression;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: UnaryExpression;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: ThisExpression;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: TemplateLiteral;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: TaggedTemplateExpression;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: SequenceExpression;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: ObjectExpression;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: SpreadElement;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: Property;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: AssignmentPattern;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: RestElement;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: ArrayPattern;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: ObjectPattern;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: PrivateIdentifier;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: NewExpression;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: Super;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: MetaProperty;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: MemberExpression;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: LogicalExpression;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: ImportExpression;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: BlockStatement;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: ConditionalExpression;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: ClassExpression;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: ClassBody;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: StaticBlock;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: PropertyDefinition;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: MethodDefinition;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: ChainExpression;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: SimpleCallExpression;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: BinaryExpression;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: AwaitExpression;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: AssignmentExpression;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: ArrowFunctionExpression;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: ArrayExpression;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: MaybeNamedClassDeclaration;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: MaybeNamedFunctionDeclaration;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: ExportNamedDeclaration;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: ExportSpecifier;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: VariableDeclaration;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: VariableDeclarator;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: ImportDeclaration;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: ImportNamespaceSpecifier;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: ImportDefaultSpecifier;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: ImportSpecifier;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: ForOfStatement;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: ForInStatement;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: ForStatement;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: DoWhileStatement;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: WhileStatement;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: TryStatement;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: CatchClause;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: ThrowStatement;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: SwitchStatement;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: SwitchCase;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: IfStatement;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: ContinueStatement;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: BreakStatement;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: LabeledStatement;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: ReturnStatement;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: WithStatement;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: DebuggerStatement;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: EmptyStatement;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: ExpressionStatement;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: Directive;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: RegExpLiteral;
              templateElement?: never;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: TemplateElement;
              functionExpression?: never;
            }
          | {
              program?: never;
              exportAllDeclaration?: never;
              bigIntLiteral?: never;
              simpleLiteral?: never;
              identifier?: never;
              exportDefaultDeclaration?: never;
              yieldExpression?: never;
              updateExpression?: never;
              unaryExpression?: never;
              thisExpression?: never;
              templateLiteral?: never;
              taggedTemplateExpression?: never;
              sequenceExpression?: never;
              objectExpression?: never;
              spreadElement?: never;
              property?: never;
              assignmentPattern?: never;
              restElement?: never;
              arrayPattern?: never;
              objectPattern?: never;
              privateIdentifier?: never;
              newExpression?: never;
              super?: never;
              metaProperty?: never;
              memberExpression?: never;
              logicalExpression?: never;
              importExpression?: never;
              blockStatement?: never;
              conditionalExpression?: never;
              classExpression?: never;
              classBody?: never;
              staticBlock?: never;
              propertyDefinition?: never;
              methodDefinition?: never;
              chainExpression?: never;
              simpleCallExpression?: never;
              binaryExpression?: never;
              awaitExpression?: never;
              assignmentExpression?: never;
              arrowFunctionExpression?: never;
              arrayExpression?: never;
              maybeNamedClassDeclaration?: never;
              maybeNamedFunctionDeclaration?: never;
              exportNamedDeclaration?: never;
              exportSpecifier?: never;
              variableDeclaration?: never;
              variableDeclarator?: never;
              importDeclaration?: never;
              importNamespaceSpecifier?: never;
              importDefaultSpecifier?: never;
              importSpecifier?: never;
              forOfStatement?: never;
              forInStatement?: never;
              forStatement?: never;
              doWhileStatement?: never;
              whileStatement?: never;
              tryStatement?: never;
              catchClause?: never;
              throwStatement?: never;
              switchStatement?: never;
              switchCase?: never;
              ifStatement?: never;
              continueStatement?: never;
              breakStatement?: never;
              labeledStatement?: never;
              returnStatement?: never;
              withStatement?: never;
              debuggerStatement?: never;
              emptyStatement?: never;
              expressionStatement?: never;
              directive?: never;
              regExpLiteral?: never;
              templateElement?: never;
              functionExpression?: FunctionExpression;
            }
        )),
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('type' in data && data.type != undefined) {
        this.type = data.type;
      }
      if ('loc' in data && data.loc != undefined) {
        this.loc = data.loc;
      }
      if ('program' in data && data.program != undefined) {
        this.program = data.program;
      }
      if ('exportAllDeclaration' in data && data.exportAllDeclaration != undefined) {
        this.exportAllDeclaration = data.exportAllDeclaration;
      }
      if ('bigIntLiteral' in data && data.bigIntLiteral != undefined) {
        this.bigIntLiteral = data.bigIntLiteral;
      }
      if ('simpleLiteral' in data && data.simpleLiteral != undefined) {
        this.simpleLiteral = data.simpleLiteral;
      }
      if ('identifier' in data && data.identifier != undefined) {
        this.identifier = data.identifier;
      }
      if ('exportDefaultDeclaration' in data && data.exportDefaultDeclaration != undefined) {
        this.exportDefaultDeclaration = data.exportDefaultDeclaration;
      }
      if ('yieldExpression' in data && data.yieldExpression != undefined) {
        this.yieldExpression = data.yieldExpression;
      }
      if ('updateExpression' in data && data.updateExpression != undefined) {
        this.updateExpression = data.updateExpression;
      }
      if ('unaryExpression' in data && data.unaryExpression != undefined) {
        this.unaryExpression = data.unaryExpression;
      }
      if ('thisExpression' in data && data.thisExpression != undefined) {
        this.thisExpression = data.thisExpression;
      }
      if ('templateLiteral' in data && data.templateLiteral != undefined) {
        this.templateLiteral = data.templateLiteral;
      }
      if ('taggedTemplateExpression' in data && data.taggedTemplateExpression != undefined) {
        this.taggedTemplateExpression = data.taggedTemplateExpression;
      }
      if ('sequenceExpression' in data && data.sequenceExpression != undefined) {
        this.sequenceExpression = data.sequenceExpression;
      }
      if ('objectExpression' in data && data.objectExpression != undefined) {
        this.objectExpression = data.objectExpression;
      }
      if ('spreadElement' in data && data.spreadElement != undefined) {
        this.spreadElement = data.spreadElement;
      }
      if ('property' in data && data.property != undefined) {
        this.property = data.property;
      }
      if ('assignmentPattern' in data && data.assignmentPattern != undefined) {
        this.assignmentPattern = data.assignmentPattern;
      }
      if ('restElement' in data && data.restElement != undefined) {
        this.restElement = data.restElement;
      }
      if ('arrayPattern' in data && data.arrayPattern != undefined) {
        this.arrayPattern = data.arrayPattern;
      }
      if ('objectPattern' in data && data.objectPattern != undefined) {
        this.objectPattern = data.objectPattern;
      }
      if ('privateIdentifier' in data && data.privateIdentifier != undefined) {
        this.privateIdentifier = data.privateIdentifier;
      }
      if ('newExpression' in data && data.newExpression != undefined) {
        this.newExpression = data.newExpression;
      }
      if ('super' in data && data.super != undefined) {
        this.super = data.super;
      }
      if ('metaProperty' in data && data.metaProperty != undefined) {
        this.metaProperty = data.metaProperty;
      }
      if ('memberExpression' in data && data.memberExpression != undefined) {
        this.memberExpression = data.memberExpression;
      }
      if ('logicalExpression' in data && data.logicalExpression != undefined) {
        this.logicalExpression = data.logicalExpression;
      }
      if ('importExpression' in data && data.importExpression != undefined) {
        this.importExpression = data.importExpression;
      }
      if ('blockStatement' in data && data.blockStatement != undefined) {
        this.blockStatement = data.blockStatement;
      }
      if ('conditionalExpression' in data && data.conditionalExpression != undefined) {
        this.conditionalExpression = data.conditionalExpression;
      }
      if ('classExpression' in data && data.classExpression != undefined) {
        this.classExpression = data.classExpression;
      }
      if ('classBody' in data && data.classBody != undefined) {
        this.classBody = data.classBody;
      }
      if ('staticBlock' in data && data.staticBlock != undefined) {
        this.staticBlock = data.staticBlock;
      }
      if ('propertyDefinition' in data && data.propertyDefinition != undefined) {
        this.propertyDefinition = data.propertyDefinition;
      }
      if ('methodDefinition' in data && data.methodDefinition != undefined) {
        this.methodDefinition = data.methodDefinition;
      }
      if ('chainExpression' in data && data.chainExpression != undefined) {
        this.chainExpression = data.chainExpression;
      }
      if ('simpleCallExpression' in data && data.simpleCallExpression != undefined) {
        this.simpleCallExpression = data.simpleCallExpression;
      }
      if ('binaryExpression' in data && data.binaryExpression != undefined) {
        this.binaryExpression = data.binaryExpression;
      }
      if ('awaitExpression' in data && data.awaitExpression != undefined) {
        this.awaitExpression = data.awaitExpression;
      }
      if ('assignmentExpression' in data && data.assignmentExpression != undefined) {
        this.assignmentExpression = data.assignmentExpression;
      }
      if ('arrowFunctionExpression' in data && data.arrowFunctionExpression != undefined) {
        this.arrowFunctionExpression = data.arrowFunctionExpression;
      }
      if ('arrayExpression' in data && data.arrayExpression != undefined) {
        this.arrayExpression = data.arrayExpression;
      }
      if ('maybeNamedClassDeclaration' in data && data.maybeNamedClassDeclaration != undefined) {
        this.maybeNamedClassDeclaration = data.maybeNamedClassDeclaration;
      }
      if (
        'maybeNamedFunctionDeclaration' in data &&
        data.maybeNamedFunctionDeclaration != undefined
      ) {
        this.maybeNamedFunctionDeclaration = data.maybeNamedFunctionDeclaration;
      }
      if ('exportNamedDeclaration' in data && data.exportNamedDeclaration != undefined) {
        this.exportNamedDeclaration = data.exportNamedDeclaration;
      }
      if ('exportSpecifier' in data && data.exportSpecifier != undefined) {
        this.exportSpecifier = data.exportSpecifier;
      }
      if ('variableDeclaration' in data && data.variableDeclaration != undefined) {
        this.variableDeclaration = data.variableDeclaration;
      }
      if ('variableDeclarator' in data && data.variableDeclarator != undefined) {
        this.variableDeclarator = data.variableDeclarator;
      }
      if ('importDeclaration' in data && data.importDeclaration != undefined) {
        this.importDeclaration = data.importDeclaration;
      }
      if ('importNamespaceSpecifier' in data && data.importNamespaceSpecifier != undefined) {
        this.importNamespaceSpecifier = data.importNamespaceSpecifier;
      }
      if ('importDefaultSpecifier' in data && data.importDefaultSpecifier != undefined) {
        this.importDefaultSpecifier = data.importDefaultSpecifier;
      }
      if ('importSpecifier' in data && data.importSpecifier != undefined) {
        this.importSpecifier = data.importSpecifier;
      }
      if ('forOfStatement' in data && data.forOfStatement != undefined) {
        this.forOfStatement = data.forOfStatement;
      }
      if ('forInStatement' in data && data.forInStatement != undefined) {
        this.forInStatement = data.forInStatement;
      }
      if ('forStatement' in data && data.forStatement != undefined) {
        this.forStatement = data.forStatement;
      }
      if ('doWhileStatement' in data && data.doWhileStatement != undefined) {
        this.doWhileStatement = data.doWhileStatement;
      }
      if ('whileStatement' in data && data.whileStatement != undefined) {
        this.whileStatement = data.whileStatement;
      }
      if ('tryStatement' in data && data.tryStatement != undefined) {
        this.tryStatement = data.tryStatement;
      }
      if ('catchClause' in data && data.catchClause != undefined) {
        this.catchClause = data.catchClause;
      }
      if ('throwStatement' in data && data.throwStatement != undefined) {
        this.throwStatement = data.throwStatement;
      }
      if ('switchStatement' in data && data.switchStatement != undefined) {
        this.switchStatement = data.switchStatement;
      }
      if ('switchCase' in data && data.switchCase != undefined) {
        this.switchCase = data.switchCase;
      }
      if ('ifStatement' in data && data.ifStatement != undefined) {
        this.ifStatement = data.ifStatement;
      }
      if ('continueStatement' in data && data.continueStatement != undefined) {
        this.continueStatement = data.continueStatement;
      }
      if ('breakStatement' in data && data.breakStatement != undefined) {
        this.breakStatement = data.breakStatement;
      }
      if ('labeledStatement' in data && data.labeledStatement != undefined) {
        this.labeledStatement = data.labeledStatement;
      }
      if ('returnStatement' in data && data.returnStatement != undefined) {
        this.returnStatement = data.returnStatement;
      }
      if ('withStatement' in data && data.withStatement != undefined) {
        this.withStatement = data.withStatement;
      }
      if ('debuggerStatement' in data && data.debuggerStatement != undefined) {
        this.debuggerStatement = data.debuggerStatement;
      }
      if ('emptyStatement' in data && data.emptyStatement != undefined) {
        this.emptyStatement = data.emptyStatement;
      }
      if ('expressionStatement' in data && data.expressionStatement != undefined) {
        this.expressionStatement = data.expressionStatement;
      }
      if ('directive' in data && data.directive != undefined) {
        this.directive = data.directive;
      }
      if ('regExpLiteral' in data && data.regExpLiteral != undefined) {
        this.regExpLiteral = data.regExpLiteral;
      }
      if ('templateElement' in data && data.templateElement != undefined) {
        this.templateElement = data.templateElement;
      }
      if ('functionExpression' in data && data.functionExpression != undefined) {
        this.functionExpression = data.functionExpression;
      }
    }
  }
  get type() {
    return pb_1.Message.getFieldWithDefault(this, 1, NodeType.ProgramType) as NodeType;
  }
  set type(value: NodeType) {
    pb_1.Message.setField(this, 1, value);
  }
  get loc() {
    return pb_1.Message.getWrapperField(this, SourceLocation, 2) as SourceLocation;
  }
  set loc(value: SourceLocation) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_loc() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get program() {
    return pb_1.Message.getWrapperField(this, Program, 3) as Program;
  }
  set program(value: Program) {
    pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
  }
  get has_program() {
    return pb_1.Message.getField(this, 3) != null;
  }
  get exportAllDeclaration() {
    return pb_1.Message.getWrapperField(this, ExportAllDeclaration, 4) as ExportAllDeclaration;
  }
  set exportAllDeclaration(value: ExportAllDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
  }
  get has_exportAllDeclaration() {
    return pb_1.Message.getField(this, 4) != null;
  }
  get bigIntLiteral() {
    return pb_1.Message.getWrapperField(this, BigIntLiteral, 5) as BigIntLiteral;
  }
  set bigIntLiteral(value: BigIntLiteral) {
    pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
  }
  get has_bigIntLiteral() {
    return pb_1.Message.getField(this, 5) != null;
  }
  get simpleLiteral() {
    return pb_1.Message.getWrapperField(this, SimpleLiteral, 6) as SimpleLiteral;
  }
  set simpleLiteral(value: SimpleLiteral) {
    pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
  }
  get has_simpleLiteral() {
    return pb_1.Message.getField(this, 6) != null;
  }
  get identifier() {
    return pb_1.Message.getWrapperField(this, Identifier, 7) as Identifier;
  }
  set identifier(value: Identifier) {
    pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
  }
  get has_identifier() {
    return pb_1.Message.getField(this, 7) != null;
  }
  get exportDefaultDeclaration() {
    return pb_1.Message.getWrapperField(
      this,
      ExportDefaultDeclaration,
      8,
    ) as ExportDefaultDeclaration;
  }
  set exportDefaultDeclaration(value: ExportDefaultDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
  }
  get has_exportDefaultDeclaration() {
    return pb_1.Message.getField(this, 8) != null;
  }
  get yieldExpression() {
    return pb_1.Message.getWrapperField(this, YieldExpression, 9) as YieldExpression;
  }
  set yieldExpression(value: YieldExpression) {
    pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
  }
  get has_yieldExpression() {
    return pb_1.Message.getField(this, 9) != null;
  }
  get updateExpression() {
    return pb_1.Message.getWrapperField(this, UpdateExpression, 10) as UpdateExpression;
  }
  set updateExpression(value: UpdateExpression) {
    pb_1.Message.setOneofWrapperField(this, 10, this.#one_of_decls[0], value);
  }
  get has_updateExpression() {
    return pb_1.Message.getField(this, 10) != null;
  }
  get unaryExpression() {
    return pb_1.Message.getWrapperField(this, UnaryExpression, 11) as UnaryExpression;
  }
  set unaryExpression(value: UnaryExpression) {
    pb_1.Message.setOneofWrapperField(this, 11, this.#one_of_decls[0], value);
  }
  get has_unaryExpression() {
    return pb_1.Message.getField(this, 11) != null;
  }
  get thisExpression() {
    return pb_1.Message.getWrapperField(this, ThisExpression, 12) as ThisExpression;
  }
  set thisExpression(value: ThisExpression) {
    pb_1.Message.setOneofWrapperField(this, 12, this.#one_of_decls[0], value);
  }
  get has_thisExpression() {
    return pb_1.Message.getField(this, 12) != null;
  }
  get templateLiteral() {
    return pb_1.Message.getWrapperField(this, TemplateLiteral, 13) as TemplateLiteral;
  }
  set templateLiteral(value: TemplateLiteral) {
    pb_1.Message.setOneofWrapperField(this, 13, this.#one_of_decls[0], value);
  }
  get has_templateLiteral() {
    return pb_1.Message.getField(this, 13) != null;
  }
  get taggedTemplateExpression() {
    return pb_1.Message.getWrapperField(
      this,
      TaggedTemplateExpression,
      14,
    ) as TaggedTemplateExpression;
  }
  set taggedTemplateExpression(value: TaggedTemplateExpression) {
    pb_1.Message.setOneofWrapperField(this, 14, this.#one_of_decls[0], value);
  }
  get has_taggedTemplateExpression() {
    return pb_1.Message.getField(this, 14) != null;
  }
  get sequenceExpression() {
    return pb_1.Message.getWrapperField(this, SequenceExpression, 15) as SequenceExpression;
  }
  set sequenceExpression(value: SequenceExpression) {
    pb_1.Message.setOneofWrapperField(this, 15, this.#one_of_decls[0], value);
  }
  get has_sequenceExpression() {
    return pb_1.Message.getField(this, 15) != null;
  }
  get objectExpression() {
    return pb_1.Message.getWrapperField(this, ObjectExpression, 16) as ObjectExpression;
  }
  set objectExpression(value: ObjectExpression) {
    pb_1.Message.setOneofWrapperField(this, 16, this.#one_of_decls[0], value);
  }
  get has_objectExpression() {
    return pb_1.Message.getField(this, 16) != null;
  }
  get spreadElement() {
    return pb_1.Message.getWrapperField(this, SpreadElement, 17) as SpreadElement;
  }
  set spreadElement(value: SpreadElement) {
    pb_1.Message.setOneofWrapperField(this, 17, this.#one_of_decls[0], value);
  }
  get has_spreadElement() {
    return pb_1.Message.getField(this, 17) != null;
  }
  get property() {
    return pb_1.Message.getWrapperField(this, Property, 18) as Property;
  }
  set property(value: Property) {
    pb_1.Message.setOneofWrapperField(this, 18, this.#one_of_decls[0], value);
  }
  get has_property() {
    return pb_1.Message.getField(this, 18) != null;
  }
  get assignmentPattern() {
    return pb_1.Message.getWrapperField(this, AssignmentPattern, 19) as AssignmentPattern;
  }
  set assignmentPattern(value: AssignmentPattern) {
    pb_1.Message.setOneofWrapperField(this, 19, this.#one_of_decls[0], value);
  }
  get has_assignmentPattern() {
    return pb_1.Message.getField(this, 19) != null;
  }
  get restElement() {
    return pb_1.Message.getWrapperField(this, RestElement, 20) as RestElement;
  }
  set restElement(value: RestElement) {
    pb_1.Message.setOneofWrapperField(this, 20, this.#one_of_decls[0], value);
  }
  get has_restElement() {
    return pb_1.Message.getField(this, 20) != null;
  }
  get arrayPattern() {
    return pb_1.Message.getWrapperField(this, ArrayPattern, 21) as ArrayPattern;
  }
  set arrayPattern(value: ArrayPattern) {
    pb_1.Message.setOneofWrapperField(this, 21, this.#one_of_decls[0], value);
  }
  get has_arrayPattern() {
    return pb_1.Message.getField(this, 21) != null;
  }
  get objectPattern() {
    return pb_1.Message.getWrapperField(this, ObjectPattern, 22) as ObjectPattern;
  }
  set objectPattern(value: ObjectPattern) {
    pb_1.Message.setOneofWrapperField(this, 22, this.#one_of_decls[0], value);
  }
  get has_objectPattern() {
    return pb_1.Message.getField(this, 22) != null;
  }
  get privateIdentifier() {
    return pb_1.Message.getWrapperField(this, PrivateIdentifier, 23) as PrivateIdentifier;
  }
  set privateIdentifier(value: PrivateIdentifier) {
    pb_1.Message.setOneofWrapperField(this, 23, this.#one_of_decls[0], value);
  }
  get has_privateIdentifier() {
    return pb_1.Message.getField(this, 23) != null;
  }
  get newExpression() {
    return pb_1.Message.getWrapperField(this, NewExpression, 24) as NewExpression;
  }
  set newExpression(value: NewExpression) {
    pb_1.Message.setOneofWrapperField(this, 24, this.#one_of_decls[0], value);
  }
  get has_newExpression() {
    return pb_1.Message.getField(this, 24) != null;
  }
  get super() {
    return pb_1.Message.getWrapperField(this, Super, 25) as Super;
  }
  set super(value: Super) {
    pb_1.Message.setOneofWrapperField(this, 25, this.#one_of_decls[0], value);
  }
  get has_super() {
    return pb_1.Message.getField(this, 25) != null;
  }
  get metaProperty() {
    return pb_1.Message.getWrapperField(this, MetaProperty, 26) as MetaProperty;
  }
  set metaProperty(value: MetaProperty) {
    pb_1.Message.setOneofWrapperField(this, 26, this.#one_of_decls[0], value);
  }
  get has_metaProperty() {
    return pb_1.Message.getField(this, 26) != null;
  }
  get memberExpression() {
    return pb_1.Message.getWrapperField(this, MemberExpression, 27) as MemberExpression;
  }
  set memberExpression(value: MemberExpression) {
    pb_1.Message.setOneofWrapperField(this, 27, this.#one_of_decls[0], value);
  }
  get has_memberExpression() {
    return pb_1.Message.getField(this, 27) != null;
  }
  get logicalExpression() {
    return pb_1.Message.getWrapperField(this, LogicalExpression, 28) as LogicalExpression;
  }
  set logicalExpression(value: LogicalExpression) {
    pb_1.Message.setOneofWrapperField(this, 28, this.#one_of_decls[0], value);
  }
  get has_logicalExpression() {
    return pb_1.Message.getField(this, 28) != null;
  }
  get importExpression() {
    return pb_1.Message.getWrapperField(this, ImportExpression, 29) as ImportExpression;
  }
  set importExpression(value: ImportExpression) {
    pb_1.Message.setOneofWrapperField(this, 29, this.#one_of_decls[0], value);
  }
  get has_importExpression() {
    return pb_1.Message.getField(this, 29) != null;
  }
  get blockStatement() {
    return pb_1.Message.getWrapperField(this, BlockStatement, 30) as BlockStatement;
  }
  set blockStatement(value: BlockStatement) {
    pb_1.Message.setOneofWrapperField(this, 30, this.#one_of_decls[0], value);
  }
  get has_blockStatement() {
    return pb_1.Message.getField(this, 30) != null;
  }
  get conditionalExpression() {
    return pb_1.Message.getWrapperField(this, ConditionalExpression, 31) as ConditionalExpression;
  }
  set conditionalExpression(value: ConditionalExpression) {
    pb_1.Message.setOneofWrapperField(this, 31, this.#one_of_decls[0], value);
  }
  get has_conditionalExpression() {
    return pb_1.Message.getField(this, 31) != null;
  }
  get classExpression() {
    return pb_1.Message.getWrapperField(this, ClassExpression, 32) as ClassExpression;
  }
  set classExpression(value: ClassExpression) {
    pb_1.Message.setOneofWrapperField(this, 32, this.#one_of_decls[0], value);
  }
  get has_classExpression() {
    return pb_1.Message.getField(this, 32) != null;
  }
  get classBody() {
    return pb_1.Message.getWrapperField(this, ClassBody, 33) as ClassBody;
  }
  set classBody(value: ClassBody) {
    pb_1.Message.setOneofWrapperField(this, 33, this.#one_of_decls[0], value);
  }
  get has_classBody() {
    return pb_1.Message.getField(this, 33) != null;
  }
  get staticBlock() {
    return pb_1.Message.getWrapperField(this, StaticBlock, 34) as StaticBlock;
  }
  set staticBlock(value: StaticBlock) {
    pb_1.Message.setOneofWrapperField(this, 34, this.#one_of_decls[0], value);
  }
  get has_staticBlock() {
    return pb_1.Message.getField(this, 34) != null;
  }
  get propertyDefinition() {
    return pb_1.Message.getWrapperField(this, PropertyDefinition, 35) as PropertyDefinition;
  }
  set propertyDefinition(value: PropertyDefinition) {
    pb_1.Message.setOneofWrapperField(this, 35, this.#one_of_decls[0], value);
  }
  get has_propertyDefinition() {
    return pb_1.Message.getField(this, 35) != null;
  }
  get methodDefinition() {
    return pb_1.Message.getWrapperField(this, MethodDefinition, 36) as MethodDefinition;
  }
  set methodDefinition(value: MethodDefinition) {
    pb_1.Message.setOneofWrapperField(this, 36, this.#one_of_decls[0], value);
  }
  get has_methodDefinition() {
    return pb_1.Message.getField(this, 36) != null;
  }
  get chainExpression() {
    return pb_1.Message.getWrapperField(this, ChainExpression, 37) as ChainExpression;
  }
  set chainExpression(value: ChainExpression) {
    pb_1.Message.setOneofWrapperField(this, 37, this.#one_of_decls[0], value);
  }
  get has_chainExpression() {
    return pb_1.Message.getField(this, 37) != null;
  }
  get simpleCallExpression() {
    return pb_1.Message.getWrapperField(this, SimpleCallExpression, 38) as SimpleCallExpression;
  }
  set simpleCallExpression(value: SimpleCallExpression) {
    pb_1.Message.setOneofWrapperField(this, 38, this.#one_of_decls[0], value);
  }
  get has_simpleCallExpression() {
    return pb_1.Message.getField(this, 38) != null;
  }
  get binaryExpression() {
    return pb_1.Message.getWrapperField(this, BinaryExpression, 39) as BinaryExpression;
  }
  set binaryExpression(value: BinaryExpression) {
    pb_1.Message.setOneofWrapperField(this, 39, this.#one_of_decls[0], value);
  }
  get has_binaryExpression() {
    return pb_1.Message.getField(this, 39) != null;
  }
  get awaitExpression() {
    return pb_1.Message.getWrapperField(this, AwaitExpression, 40) as AwaitExpression;
  }
  set awaitExpression(value: AwaitExpression) {
    pb_1.Message.setOneofWrapperField(this, 40, this.#one_of_decls[0], value);
  }
  get has_awaitExpression() {
    return pb_1.Message.getField(this, 40) != null;
  }
  get assignmentExpression() {
    return pb_1.Message.getWrapperField(this, AssignmentExpression, 41) as AssignmentExpression;
  }
  set assignmentExpression(value: AssignmentExpression) {
    pb_1.Message.setOneofWrapperField(this, 41, this.#one_of_decls[0], value);
  }
  get has_assignmentExpression() {
    return pb_1.Message.getField(this, 41) != null;
  }
  get arrowFunctionExpression() {
    return pb_1.Message.getWrapperField(
      this,
      ArrowFunctionExpression,
      42,
    ) as ArrowFunctionExpression;
  }
  set arrowFunctionExpression(value: ArrowFunctionExpression) {
    pb_1.Message.setOneofWrapperField(this, 42, this.#one_of_decls[0], value);
  }
  get has_arrowFunctionExpression() {
    return pb_1.Message.getField(this, 42) != null;
  }
  get arrayExpression() {
    return pb_1.Message.getWrapperField(this, ArrayExpression, 43) as ArrayExpression;
  }
  set arrayExpression(value: ArrayExpression) {
    pb_1.Message.setOneofWrapperField(this, 43, this.#one_of_decls[0], value);
  }
  get has_arrayExpression() {
    return pb_1.Message.getField(this, 43) != null;
  }
  get maybeNamedClassDeclaration() {
    return pb_1.Message.getWrapperField(
      this,
      MaybeNamedClassDeclaration,
      44,
    ) as MaybeNamedClassDeclaration;
  }
  set maybeNamedClassDeclaration(value: MaybeNamedClassDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 44, this.#one_of_decls[0], value);
  }
  get has_maybeNamedClassDeclaration() {
    return pb_1.Message.getField(this, 44) != null;
  }
  get maybeNamedFunctionDeclaration() {
    return pb_1.Message.getWrapperField(
      this,
      MaybeNamedFunctionDeclaration,
      45,
    ) as MaybeNamedFunctionDeclaration;
  }
  set maybeNamedFunctionDeclaration(value: MaybeNamedFunctionDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 45, this.#one_of_decls[0], value);
  }
  get has_maybeNamedFunctionDeclaration() {
    return pb_1.Message.getField(this, 45) != null;
  }
  get exportNamedDeclaration() {
    return pb_1.Message.getWrapperField(this, ExportNamedDeclaration, 46) as ExportNamedDeclaration;
  }
  set exportNamedDeclaration(value: ExportNamedDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 46, this.#one_of_decls[0], value);
  }
  get has_exportNamedDeclaration() {
    return pb_1.Message.getField(this, 46) != null;
  }
  get exportSpecifier() {
    return pb_1.Message.getWrapperField(this, ExportSpecifier, 47) as ExportSpecifier;
  }
  set exportSpecifier(value: ExportSpecifier) {
    pb_1.Message.setOneofWrapperField(this, 47, this.#one_of_decls[0], value);
  }
  get has_exportSpecifier() {
    return pb_1.Message.getField(this, 47) != null;
  }
  get variableDeclaration() {
    return pb_1.Message.getWrapperField(this, VariableDeclaration, 48) as VariableDeclaration;
  }
  set variableDeclaration(value: VariableDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 48, this.#one_of_decls[0], value);
  }
  get has_variableDeclaration() {
    return pb_1.Message.getField(this, 48) != null;
  }
  get variableDeclarator() {
    return pb_1.Message.getWrapperField(this, VariableDeclarator, 49) as VariableDeclarator;
  }
  set variableDeclarator(value: VariableDeclarator) {
    pb_1.Message.setOneofWrapperField(this, 49, this.#one_of_decls[0], value);
  }
  get has_variableDeclarator() {
    return pb_1.Message.getField(this, 49) != null;
  }
  get importDeclaration() {
    return pb_1.Message.getWrapperField(this, ImportDeclaration, 50) as ImportDeclaration;
  }
  set importDeclaration(value: ImportDeclaration) {
    pb_1.Message.setOneofWrapperField(this, 50, this.#one_of_decls[0], value);
  }
  get has_importDeclaration() {
    return pb_1.Message.getField(this, 50) != null;
  }
  get importNamespaceSpecifier() {
    return pb_1.Message.getWrapperField(
      this,
      ImportNamespaceSpecifier,
      51,
    ) as ImportNamespaceSpecifier;
  }
  set importNamespaceSpecifier(value: ImportNamespaceSpecifier) {
    pb_1.Message.setOneofWrapperField(this, 51, this.#one_of_decls[0], value);
  }
  get has_importNamespaceSpecifier() {
    return pb_1.Message.getField(this, 51) != null;
  }
  get importDefaultSpecifier() {
    return pb_1.Message.getWrapperField(this, ImportDefaultSpecifier, 52) as ImportDefaultSpecifier;
  }
  set importDefaultSpecifier(value: ImportDefaultSpecifier) {
    pb_1.Message.setOneofWrapperField(this, 52, this.#one_of_decls[0], value);
  }
  get has_importDefaultSpecifier() {
    return pb_1.Message.getField(this, 52) != null;
  }
  get importSpecifier() {
    return pb_1.Message.getWrapperField(this, ImportSpecifier, 53) as ImportSpecifier;
  }
  set importSpecifier(value: ImportSpecifier) {
    pb_1.Message.setOneofWrapperField(this, 53, this.#one_of_decls[0], value);
  }
  get has_importSpecifier() {
    return pb_1.Message.getField(this, 53) != null;
  }
  get forOfStatement() {
    return pb_1.Message.getWrapperField(this, ForOfStatement, 54) as ForOfStatement;
  }
  set forOfStatement(value: ForOfStatement) {
    pb_1.Message.setOneofWrapperField(this, 54, this.#one_of_decls[0], value);
  }
  get has_forOfStatement() {
    return pb_1.Message.getField(this, 54) != null;
  }
  get forInStatement() {
    return pb_1.Message.getWrapperField(this, ForInStatement, 55) as ForInStatement;
  }
  set forInStatement(value: ForInStatement) {
    pb_1.Message.setOneofWrapperField(this, 55, this.#one_of_decls[0], value);
  }
  get has_forInStatement() {
    return pb_1.Message.getField(this, 55) != null;
  }
  get forStatement() {
    return pb_1.Message.getWrapperField(this, ForStatement, 56) as ForStatement;
  }
  set forStatement(value: ForStatement) {
    pb_1.Message.setOneofWrapperField(this, 56, this.#one_of_decls[0], value);
  }
  get has_forStatement() {
    return pb_1.Message.getField(this, 56) != null;
  }
  get doWhileStatement() {
    return pb_1.Message.getWrapperField(this, DoWhileStatement, 57) as DoWhileStatement;
  }
  set doWhileStatement(value: DoWhileStatement) {
    pb_1.Message.setOneofWrapperField(this, 57, this.#one_of_decls[0], value);
  }
  get has_doWhileStatement() {
    return pb_1.Message.getField(this, 57) != null;
  }
  get whileStatement() {
    return pb_1.Message.getWrapperField(this, WhileStatement, 58) as WhileStatement;
  }
  set whileStatement(value: WhileStatement) {
    pb_1.Message.setOneofWrapperField(this, 58, this.#one_of_decls[0], value);
  }
  get has_whileStatement() {
    return pb_1.Message.getField(this, 58) != null;
  }
  get tryStatement() {
    return pb_1.Message.getWrapperField(this, TryStatement, 59) as TryStatement;
  }
  set tryStatement(value: TryStatement) {
    pb_1.Message.setOneofWrapperField(this, 59, this.#one_of_decls[0], value);
  }
  get has_tryStatement() {
    return pb_1.Message.getField(this, 59) != null;
  }
  get catchClause() {
    return pb_1.Message.getWrapperField(this, CatchClause, 60) as CatchClause;
  }
  set catchClause(value: CatchClause) {
    pb_1.Message.setOneofWrapperField(this, 60, this.#one_of_decls[0], value);
  }
  get has_catchClause() {
    return pb_1.Message.getField(this, 60) != null;
  }
  get throwStatement() {
    return pb_1.Message.getWrapperField(this, ThrowStatement, 61) as ThrowStatement;
  }
  set throwStatement(value: ThrowStatement) {
    pb_1.Message.setOneofWrapperField(this, 61, this.#one_of_decls[0], value);
  }
  get has_throwStatement() {
    return pb_1.Message.getField(this, 61) != null;
  }
  get switchStatement() {
    return pb_1.Message.getWrapperField(this, SwitchStatement, 62) as SwitchStatement;
  }
  set switchStatement(value: SwitchStatement) {
    pb_1.Message.setOneofWrapperField(this, 62, this.#one_of_decls[0], value);
  }
  get has_switchStatement() {
    return pb_1.Message.getField(this, 62) != null;
  }
  get switchCase() {
    return pb_1.Message.getWrapperField(this, SwitchCase, 63) as SwitchCase;
  }
  set switchCase(value: SwitchCase) {
    pb_1.Message.setOneofWrapperField(this, 63, this.#one_of_decls[0], value);
  }
  get has_switchCase() {
    return pb_1.Message.getField(this, 63) != null;
  }
  get ifStatement() {
    return pb_1.Message.getWrapperField(this, IfStatement, 64) as IfStatement;
  }
  set ifStatement(value: IfStatement) {
    pb_1.Message.setOneofWrapperField(this, 64, this.#one_of_decls[0], value);
  }
  get has_ifStatement() {
    return pb_1.Message.getField(this, 64) != null;
  }
  get continueStatement() {
    return pb_1.Message.getWrapperField(this, ContinueStatement, 65) as ContinueStatement;
  }
  set continueStatement(value: ContinueStatement) {
    pb_1.Message.setOneofWrapperField(this, 65, this.#one_of_decls[0], value);
  }
  get has_continueStatement() {
    return pb_1.Message.getField(this, 65) != null;
  }
  get breakStatement() {
    return pb_1.Message.getWrapperField(this, BreakStatement, 66) as BreakStatement;
  }
  set breakStatement(value: BreakStatement) {
    pb_1.Message.setOneofWrapperField(this, 66, this.#one_of_decls[0], value);
  }
  get has_breakStatement() {
    return pb_1.Message.getField(this, 66) != null;
  }
  get labeledStatement() {
    return pb_1.Message.getWrapperField(this, LabeledStatement, 67) as LabeledStatement;
  }
  set labeledStatement(value: LabeledStatement) {
    pb_1.Message.setOneofWrapperField(this, 67, this.#one_of_decls[0], value);
  }
  get has_labeledStatement() {
    return pb_1.Message.getField(this, 67) != null;
  }
  get returnStatement() {
    return pb_1.Message.getWrapperField(this, ReturnStatement, 68) as ReturnStatement;
  }
  set returnStatement(value: ReturnStatement) {
    pb_1.Message.setOneofWrapperField(this, 68, this.#one_of_decls[0], value);
  }
  get has_returnStatement() {
    return pb_1.Message.getField(this, 68) != null;
  }
  get withStatement() {
    return pb_1.Message.getWrapperField(this, WithStatement, 69) as WithStatement;
  }
  set withStatement(value: WithStatement) {
    pb_1.Message.setOneofWrapperField(this, 69, this.#one_of_decls[0], value);
  }
  get has_withStatement() {
    return pb_1.Message.getField(this, 69) != null;
  }
  get debuggerStatement() {
    return pb_1.Message.getWrapperField(this, DebuggerStatement, 70) as DebuggerStatement;
  }
  set debuggerStatement(value: DebuggerStatement) {
    pb_1.Message.setOneofWrapperField(this, 70, this.#one_of_decls[0], value);
  }
  get has_debuggerStatement() {
    return pb_1.Message.getField(this, 70) != null;
  }
  get emptyStatement() {
    return pb_1.Message.getWrapperField(this, EmptyStatement, 71) as EmptyStatement;
  }
  set emptyStatement(value: EmptyStatement) {
    pb_1.Message.setOneofWrapperField(this, 71, this.#one_of_decls[0], value);
  }
  get has_emptyStatement() {
    return pb_1.Message.getField(this, 71) != null;
  }
  get expressionStatement() {
    return pb_1.Message.getWrapperField(this, ExpressionStatement, 72) as ExpressionStatement;
  }
  set expressionStatement(value: ExpressionStatement) {
    pb_1.Message.setOneofWrapperField(this, 72, this.#one_of_decls[0], value);
  }
  get has_expressionStatement() {
    return pb_1.Message.getField(this, 72) != null;
  }
  get directive() {
    return pb_1.Message.getWrapperField(this, Directive, 73) as Directive;
  }
  set directive(value: Directive) {
    pb_1.Message.setOneofWrapperField(this, 73, this.#one_of_decls[0], value);
  }
  get has_directive() {
    return pb_1.Message.getField(this, 73) != null;
  }
  get regExpLiteral() {
    return pb_1.Message.getWrapperField(this, RegExpLiteral, 74) as RegExpLiteral;
  }
  set regExpLiteral(value: RegExpLiteral) {
    pb_1.Message.setOneofWrapperField(this, 74, this.#one_of_decls[0], value);
  }
  get has_regExpLiteral() {
    return pb_1.Message.getField(this, 74) != null;
  }
  get templateElement() {
    return pb_1.Message.getWrapperField(this, TemplateElement, 75) as TemplateElement;
  }
  set templateElement(value: TemplateElement) {
    pb_1.Message.setOneofWrapperField(this, 75, this.#one_of_decls[0], value);
  }
  get has_templateElement() {
    return pb_1.Message.getField(this, 75) != null;
  }
  get functionExpression() {
    return pb_1.Message.getWrapperField(this, FunctionExpression, 76) as FunctionExpression;
  }
  set functionExpression(value: FunctionExpression) {
    pb_1.Message.setOneofWrapperField(this, 76, this.#one_of_decls[0], value);
  }
  get has_functionExpression() {
    return pb_1.Message.getField(this, 76) != null;
  }
  get node() {
    const cases: {
      [index: number]:
        | 'none'
        | 'program'
        | 'exportAllDeclaration'
        | 'bigIntLiteral'
        | 'simpleLiteral'
        | 'identifier'
        | 'exportDefaultDeclaration'
        | 'yieldExpression'
        | 'updateExpression'
        | 'unaryExpression'
        | 'thisExpression'
        | 'templateLiteral'
        | 'taggedTemplateExpression'
        | 'sequenceExpression'
        | 'objectExpression'
        | 'spreadElement'
        | 'property'
        | 'assignmentPattern'
        | 'restElement'
        | 'arrayPattern'
        | 'objectPattern'
        | 'privateIdentifier'
        | 'newExpression'
        | 'super'
        | 'metaProperty'
        | 'memberExpression'
        | 'logicalExpression'
        | 'importExpression'
        | 'blockStatement'
        | 'conditionalExpression'
        | 'classExpression'
        | 'classBody'
        | 'staticBlock'
        | 'propertyDefinition'
        | 'methodDefinition'
        | 'chainExpression'
        | 'simpleCallExpression'
        | 'binaryExpression'
        | 'awaitExpression'
        | 'assignmentExpression'
        | 'arrowFunctionExpression'
        | 'arrayExpression'
        | 'maybeNamedClassDeclaration'
        | 'maybeNamedFunctionDeclaration'
        | 'exportNamedDeclaration'
        | 'exportSpecifier'
        | 'variableDeclaration'
        | 'variableDeclarator'
        | 'importDeclaration'
        | 'importNamespaceSpecifier'
        | 'importDefaultSpecifier'
        | 'importSpecifier'
        | 'forOfStatement'
        | 'forInStatement'
        | 'forStatement'
        | 'doWhileStatement'
        | 'whileStatement'
        | 'tryStatement'
        | 'catchClause'
        | 'throwStatement'
        | 'switchStatement'
        | 'switchCase'
        | 'ifStatement'
        | 'continueStatement'
        | 'breakStatement'
        | 'labeledStatement'
        | 'returnStatement'
        | 'withStatement'
        | 'debuggerStatement'
        | 'emptyStatement'
        | 'expressionStatement'
        | 'directive'
        | 'regExpLiteral'
        | 'templateElement'
        | 'functionExpression';
    } = {
      0: 'none',
      3: 'program',
      4: 'exportAllDeclaration',
      5: 'bigIntLiteral',
      6: 'simpleLiteral',
      7: 'identifier',
      8: 'exportDefaultDeclaration',
      9: 'yieldExpression',
      10: 'updateExpression',
      11: 'unaryExpression',
      12: 'thisExpression',
      13: 'templateLiteral',
      14: 'taggedTemplateExpression',
      15: 'sequenceExpression',
      16: 'objectExpression',
      17: 'spreadElement',
      18: 'property',
      19: 'assignmentPattern',
      20: 'restElement',
      21: 'arrayPattern',
      22: 'objectPattern',
      23: 'privateIdentifier',
      24: 'newExpression',
      25: 'super',
      26: 'metaProperty',
      27: 'memberExpression',
      28: 'logicalExpression',
      29: 'importExpression',
      30: 'blockStatement',
      31: 'conditionalExpression',
      32: 'classExpression',
      33: 'classBody',
      34: 'staticBlock',
      35: 'propertyDefinition',
      36: 'methodDefinition',
      37: 'chainExpression',
      38: 'simpleCallExpression',
      39: 'binaryExpression',
      40: 'awaitExpression',
      41: 'assignmentExpression',
      42: 'arrowFunctionExpression',
      43: 'arrayExpression',
      44: 'maybeNamedClassDeclaration',
      45: 'maybeNamedFunctionDeclaration',
      46: 'exportNamedDeclaration',
      47: 'exportSpecifier',
      48: 'variableDeclaration',
      49: 'variableDeclarator',
      50: 'importDeclaration',
      51: 'importNamespaceSpecifier',
      52: 'importDefaultSpecifier',
      53: 'importSpecifier',
      54: 'forOfStatement',
      55: 'forInStatement',
      56: 'forStatement',
      57: 'doWhileStatement',
      58: 'whileStatement',
      59: 'tryStatement',
      60: 'catchClause',
      61: 'throwStatement',
      62: 'switchStatement',
      63: 'switchCase',
      64: 'ifStatement',
      65: 'continueStatement',
      66: 'breakStatement',
      67: 'labeledStatement',
      68: 'returnStatement',
      69: 'withStatement',
      70: 'debuggerStatement',
      71: 'emptyStatement',
      72: 'expressionStatement',
      73: 'directive',
      74: 'regExpLiteral',
      75: 'templateElement',
      76: 'functionExpression',
    };
    return cases[
      pb_1.Message.computeOneofCase(
        this,
        [
          3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
          27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
          49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
          71, 72, 73, 74, 75, 76,
        ],
      )
    ];
  }
  static fromObject(data: {
    type?: NodeType;
    loc?: ReturnType<typeof SourceLocation.prototype.toObject>;
    program?: ReturnType<typeof Program.prototype.toObject>;
    exportAllDeclaration?: ReturnType<typeof ExportAllDeclaration.prototype.toObject>;
    bigIntLiteral?: ReturnType<typeof BigIntLiteral.prototype.toObject>;
    simpleLiteral?: ReturnType<typeof SimpleLiteral.prototype.toObject>;
    identifier?: ReturnType<typeof Identifier.prototype.toObject>;
    exportDefaultDeclaration?: ReturnType<typeof ExportDefaultDeclaration.prototype.toObject>;
    yieldExpression?: ReturnType<typeof YieldExpression.prototype.toObject>;
    updateExpression?: ReturnType<typeof UpdateExpression.prototype.toObject>;
    unaryExpression?: ReturnType<typeof UnaryExpression.prototype.toObject>;
    thisExpression?: ReturnType<typeof ThisExpression.prototype.toObject>;
    templateLiteral?: ReturnType<typeof TemplateLiteral.prototype.toObject>;
    taggedTemplateExpression?: ReturnType<typeof TaggedTemplateExpression.prototype.toObject>;
    sequenceExpression?: ReturnType<typeof SequenceExpression.prototype.toObject>;
    objectExpression?: ReturnType<typeof ObjectExpression.prototype.toObject>;
    spreadElement?: ReturnType<typeof SpreadElement.prototype.toObject>;
    property?: ReturnType<typeof Property.prototype.toObject>;
    assignmentPattern?: ReturnType<typeof AssignmentPattern.prototype.toObject>;
    restElement?: ReturnType<typeof RestElement.prototype.toObject>;
    arrayPattern?: ReturnType<typeof ArrayPattern.prototype.toObject>;
    objectPattern?: ReturnType<typeof ObjectPattern.prototype.toObject>;
    privateIdentifier?: ReturnType<typeof PrivateIdentifier.prototype.toObject>;
    newExpression?: ReturnType<typeof NewExpression.prototype.toObject>;
    super?: ReturnType<typeof Super.prototype.toObject>;
    metaProperty?: ReturnType<typeof MetaProperty.prototype.toObject>;
    memberExpression?: ReturnType<typeof MemberExpression.prototype.toObject>;
    logicalExpression?: ReturnType<typeof LogicalExpression.prototype.toObject>;
    importExpression?: ReturnType<typeof ImportExpression.prototype.toObject>;
    blockStatement?: ReturnType<typeof BlockStatement.prototype.toObject>;
    conditionalExpression?: ReturnType<typeof ConditionalExpression.prototype.toObject>;
    classExpression?: ReturnType<typeof ClassExpression.prototype.toObject>;
    classBody?: ReturnType<typeof ClassBody.prototype.toObject>;
    staticBlock?: ReturnType<typeof StaticBlock.prototype.toObject>;
    propertyDefinition?: ReturnType<typeof PropertyDefinition.prototype.toObject>;
    methodDefinition?: ReturnType<typeof MethodDefinition.prototype.toObject>;
    chainExpression?: ReturnType<typeof ChainExpression.prototype.toObject>;
    simpleCallExpression?: ReturnType<typeof SimpleCallExpression.prototype.toObject>;
    binaryExpression?: ReturnType<typeof BinaryExpression.prototype.toObject>;
    awaitExpression?: ReturnType<typeof AwaitExpression.prototype.toObject>;
    assignmentExpression?: ReturnType<typeof AssignmentExpression.prototype.toObject>;
    arrowFunctionExpression?: ReturnType<typeof ArrowFunctionExpression.prototype.toObject>;
    arrayExpression?: ReturnType<typeof ArrayExpression.prototype.toObject>;
    maybeNamedClassDeclaration?: ReturnType<typeof MaybeNamedClassDeclaration.prototype.toObject>;
    maybeNamedFunctionDeclaration?: ReturnType<
      typeof MaybeNamedFunctionDeclaration.prototype.toObject
    >;
    exportNamedDeclaration?: ReturnType<typeof ExportNamedDeclaration.prototype.toObject>;
    exportSpecifier?: ReturnType<typeof ExportSpecifier.prototype.toObject>;
    variableDeclaration?: ReturnType<typeof VariableDeclaration.prototype.toObject>;
    variableDeclarator?: ReturnType<typeof VariableDeclarator.prototype.toObject>;
    importDeclaration?: ReturnType<typeof ImportDeclaration.prototype.toObject>;
    importNamespaceSpecifier?: ReturnType<typeof ImportNamespaceSpecifier.prototype.toObject>;
    importDefaultSpecifier?: ReturnType<typeof ImportDefaultSpecifier.prototype.toObject>;
    importSpecifier?: ReturnType<typeof ImportSpecifier.prototype.toObject>;
    forOfStatement?: ReturnType<typeof ForOfStatement.prototype.toObject>;
    forInStatement?: ReturnType<typeof ForInStatement.prototype.toObject>;
    forStatement?: ReturnType<typeof ForStatement.prototype.toObject>;
    doWhileStatement?: ReturnType<typeof DoWhileStatement.prototype.toObject>;
    whileStatement?: ReturnType<typeof WhileStatement.prototype.toObject>;
    tryStatement?: ReturnType<typeof TryStatement.prototype.toObject>;
    catchClause?: ReturnType<typeof CatchClause.prototype.toObject>;
    throwStatement?: ReturnType<typeof ThrowStatement.prototype.toObject>;
    switchStatement?: ReturnType<typeof SwitchStatement.prototype.toObject>;
    switchCase?: ReturnType<typeof SwitchCase.prototype.toObject>;
    ifStatement?: ReturnType<typeof IfStatement.prototype.toObject>;
    continueStatement?: ReturnType<typeof ContinueStatement.prototype.toObject>;
    breakStatement?: ReturnType<typeof BreakStatement.prototype.toObject>;
    labeledStatement?: ReturnType<typeof LabeledStatement.prototype.toObject>;
    returnStatement?: ReturnType<typeof ReturnStatement.prototype.toObject>;
    withStatement?: ReturnType<typeof WithStatement.prototype.toObject>;
    debuggerStatement?: ReturnType<typeof DebuggerStatement.prototype.toObject>;
    emptyStatement?: ReturnType<typeof EmptyStatement.prototype.toObject>;
    expressionStatement?: ReturnType<typeof ExpressionStatement.prototype.toObject>;
    directive?: ReturnType<typeof Directive.prototype.toObject>;
    regExpLiteral?: ReturnType<typeof RegExpLiteral.prototype.toObject>;
    templateElement?: ReturnType<typeof TemplateElement.prototype.toObject>;
    functionExpression?: ReturnType<typeof FunctionExpression.prototype.toObject>;
  }): Node {
    const message = new Node({});
    if (data.type != null) {
      message.type = data.type;
    }
    if (data.loc != null) {
      message.loc = SourceLocation.fromObject(data.loc);
    }
    if (data.program != null) {
      message.program = Program.fromObject(data.program);
    }
    if (data.exportAllDeclaration != null) {
      message.exportAllDeclaration = ExportAllDeclaration.fromObject(data.exportAllDeclaration);
    }
    if (data.bigIntLiteral != null) {
      message.bigIntLiteral = BigIntLiteral.fromObject(data.bigIntLiteral);
    }
    if (data.simpleLiteral != null) {
      message.simpleLiteral = SimpleLiteral.fromObject(data.simpleLiteral);
    }
    if (data.identifier != null) {
      message.identifier = Identifier.fromObject(data.identifier);
    }
    if (data.exportDefaultDeclaration != null) {
      message.exportDefaultDeclaration = ExportDefaultDeclaration.fromObject(
        data.exportDefaultDeclaration,
      );
    }
    if (data.yieldExpression != null) {
      message.yieldExpression = YieldExpression.fromObject(data.yieldExpression);
    }
    if (data.updateExpression != null) {
      message.updateExpression = UpdateExpression.fromObject(data.updateExpression);
    }
    if (data.unaryExpression != null) {
      message.unaryExpression = UnaryExpression.fromObject(data.unaryExpression);
    }
    if (data.thisExpression != null) {
      message.thisExpression = ThisExpression.fromObject(data.thisExpression);
    }
    if (data.templateLiteral != null) {
      message.templateLiteral = TemplateLiteral.fromObject(data.templateLiteral);
    }
    if (data.taggedTemplateExpression != null) {
      message.taggedTemplateExpression = TaggedTemplateExpression.fromObject(
        data.taggedTemplateExpression,
      );
    }
    if (data.sequenceExpression != null) {
      message.sequenceExpression = SequenceExpression.fromObject(data.sequenceExpression);
    }
    if (data.objectExpression != null) {
      message.objectExpression = ObjectExpression.fromObject(data.objectExpression);
    }
    if (data.spreadElement != null) {
      message.spreadElement = SpreadElement.fromObject(data.spreadElement);
    }
    if (data.property != null) {
      message.property = Property.fromObject(data.property);
    }
    if (data.assignmentPattern != null) {
      message.assignmentPattern = AssignmentPattern.fromObject(data.assignmentPattern);
    }
    if (data.restElement != null) {
      message.restElement = RestElement.fromObject(data.restElement);
    }
    if (data.arrayPattern != null) {
      message.arrayPattern = ArrayPattern.fromObject(data.arrayPattern);
    }
    if (data.objectPattern != null) {
      message.objectPattern = ObjectPattern.fromObject(data.objectPattern);
    }
    if (data.privateIdentifier != null) {
      message.privateIdentifier = PrivateIdentifier.fromObject(data.privateIdentifier);
    }
    if (data.newExpression != null) {
      message.newExpression = NewExpression.fromObject(data.newExpression);
    }
    if (data.super != null) {
      message.super = Super.fromObject(data.super);
    }
    if (data.metaProperty != null) {
      message.metaProperty = MetaProperty.fromObject(data.metaProperty);
    }
    if (data.memberExpression != null) {
      message.memberExpression = MemberExpression.fromObject(data.memberExpression);
    }
    if (data.logicalExpression != null) {
      message.logicalExpression = LogicalExpression.fromObject(data.logicalExpression);
    }
    if (data.importExpression != null) {
      message.importExpression = ImportExpression.fromObject(data.importExpression);
    }
    if (data.blockStatement != null) {
      message.blockStatement = BlockStatement.fromObject(data.blockStatement);
    }
    if (data.conditionalExpression != null) {
      message.conditionalExpression = ConditionalExpression.fromObject(data.conditionalExpression);
    }
    if (data.classExpression != null) {
      message.classExpression = ClassExpression.fromObject(data.classExpression);
    }
    if (data.classBody != null) {
      message.classBody = ClassBody.fromObject(data.classBody);
    }
    if (data.staticBlock != null) {
      message.staticBlock = StaticBlock.fromObject(data.staticBlock);
    }
    if (data.propertyDefinition != null) {
      message.propertyDefinition = PropertyDefinition.fromObject(data.propertyDefinition);
    }
    if (data.methodDefinition != null) {
      message.methodDefinition = MethodDefinition.fromObject(data.methodDefinition);
    }
    if (data.chainExpression != null) {
      message.chainExpression = ChainExpression.fromObject(data.chainExpression);
    }
    if (data.simpleCallExpression != null) {
      message.simpleCallExpression = SimpleCallExpression.fromObject(data.simpleCallExpression);
    }
    if (data.binaryExpression != null) {
      message.binaryExpression = BinaryExpression.fromObject(data.binaryExpression);
    }
    if (data.awaitExpression != null) {
      message.awaitExpression = AwaitExpression.fromObject(data.awaitExpression);
    }
    if (data.assignmentExpression != null) {
      message.assignmentExpression = AssignmentExpression.fromObject(data.assignmentExpression);
    }
    if (data.arrowFunctionExpression != null) {
      message.arrowFunctionExpression = ArrowFunctionExpression.fromObject(
        data.arrowFunctionExpression,
      );
    }
    if (data.arrayExpression != null) {
      message.arrayExpression = ArrayExpression.fromObject(data.arrayExpression);
    }
    if (data.maybeNamedClassDeclaration != null) {
      message.maybeNamedClassDeclaration = MaybeNamedClassDeclaration.fromObject(
        data.maybeNamedClassDeclaration,
      );
    }
    if (data.maybeNamedFunctionDeclaration != null) {
      message.maybeNamedFunctionDeclaration = MaybeNamedFunctionDeclaration.fromObject(
        data.maybeNamedFunctionDeclaration,
      );
    }
    if (data.exportNamedDeclaration != null) {
      message.exportNamedDeclaration = ExportNamedDeclaration.fromObject(
        data.exportNamedDeclaration,
      );
    }
    if (data.exportSpecifier != null) {
      message.exportSpecifier = ExportSpecifier.fromObject(data.exportSpecifier);
    }
    if (data.variableDeclaration != null) {
      message.variableDeclaration = VariableDeclaration.fromObject(data.variableDeclaration);
    }
    if (data.variableDeclarator != null) {
      message.variableDeclarator = VariableDeclarator.fromObject(data.variableDeclarator);
    }
    if (data.importDeclaration != null) {
      message.importDeclaration = ImportDeclaration.fromObject(data.importDeclaration);
    }
    if (data.importNamespaceSpecifier != null) {
      message.importNamespaceSpecifier = ImportNamespaceSpecifier.fromObject(
        data.importNamespaceSpecifier,
      );
    }
    if (data.importDefaultSpecifier != null) {
      message.importDefaultSpecifier = ImportDefaultSpecifier.fromObject(
        data.importDefaultSpecifier,
      );
    }
    if (data.importSpecifier != null) {
      message.importSpecifier = ImportSpecifier.fromObject(data.importSpecifier);
    }
    if (data.forOfStatement != null) {
      message.forOfStatement = ForOfStatement.fromObject(data.forOfStatement);
    }
    if (data.forInStatement != null) {
      message.forInStatement = ForInStatement.fromObject(data.forInStatement);
    }
    if (data.forStatement != null) {
      message.forStatement = ForStatement.fromObject(data.forStatement);
    }
    if (data.doWhileStatement != null) {
      message.doWhileStatement = DoWhileStatement.fromObject(data.doWhileStatement);
    }
    if (data.whileStatement != null) {
      message.whileStatement = WhileStatement.fromObject(data.whileStatement);
    }
    if (data.tryStatement != null) {
      message.tryStatement = TryStatement.fromObject(data.tryStatement);
    }
    if (data.catchClause != null) {
      message.catchClause = CatchClause.fromObject(data.catchClause);
    }
    if (data.throwStatement != null) {
      message.throwStatement = ThrowStatement.fromObject(data.throwStatement);
    }
    if (data.switchStatement != null) {
      message.switchStatement = SwitchStatement.fromObject(data.switchStatement);
    }
    if (data.switchCase != null) {
      message.switchCase = SwitchCase.fromObject(data.switchCase);
    }
    if (data.ifStatement != null) {
      message.ifStatement = IfStatement.fromObject(data.ifStatement);
    }
    if (data.continueStatement != null) {
      message.continueStatement = ContinueStatement.fromObject(data.continueStatement);
    }
    if (data.breakStatement != null) {
      message.breakStatement = BreakStatement.fromObject(data.breakStatement);
    }
    if (data.labeledStatement != null) {
      message.labeledStatement = LabeledStatement.fromObject(data.labeledStatement);
    }
    if (data.returnStatement != null) {
      message.returnStatement = ReturnStatement.fromObject(data.returnStatement);
    }
    if (data.withStatement != null) {
      message.withStatement = WithStatement.fromObject(data.withStatement);
    }
    if (data.debuggerStatement != null) {
      message.debuggerStatement = DebuggerStatement.fromObject(data.debuggerStatement);
    }
    if (data.emptyStatement != null) {
      message.emptyStatement = EmptyStatement.fromObject(data.emptyStatement);
    }
    if (data.expressionStatement != null) {
      message.expressionStatement = ExpressionStatement.fromObject(data.expressionStatement);
    }
    if (data.directive != null) {
      message.directive = Directive.fromObject(data.directive);
    }
    if (data.regExpLiteral != null) {
      message.regExpLiteral = RegExpLiteral.fromObject(data.regExpLiteral);
    }
    if (data.templateElement != null) {
      message.templateElement = TemplateElement.fromObject(data.templateElement);
    }
    if (data.functionExpression != null) {
      message.functionExpression = FunctionExpression.fromObject(data.functionExpression);
    }
    return message;
  }
  toObject() {
    const data: {
      type?: NodeType;
      loc?: ReturnType<typeof SourceLocation.prototype.toObject>;
      program?: ReturnType<typeof Program.prototype.toObject>;
      exportAllDeclaration?: ReturnType<typeof ExportAllDeclaration.prototype.toObject>;
      bigIntLiteral?: ReturnType<typeof BigIntLiteral.prototype.toObject>;
      simpleLiteral?: ReturnType<typeof SimpleLiteral.prototype.toObject>;
      identifier?: ReturnType<typeof Identifier.prototype.toObject>;
      exportDefaultDeclaration?: ReturnType<typeof ExportDefaultDeclaration.prototype.toObject>;
      yieldExpression?: ReturnType<typeof YieldExpression.prototype.toObject>;
      updateExpression?: ReturnType<typeof UpdateExpression.prototype.toObject>;
      unaryExpression?: ReturnType<typeof UnaryExpression.prototype.toObject>;
      thisExpression?: ReturnType<typeof ThisExpression.prototype.toObject>;
      templateLiteral?: ReturnType<typeof TemplateLiteral.prototype.toObject>;
      taggedTemplateExpression?: ReturnType<typeof TaggedTemplateExpression.prototype.toObject>;
      sequenceExpression?: ReturnType<typeof SequenceExpression.prototype.toObject>;
      objectExpression?: ReturnType<typeof ObjectExpression.prototype.toObject>;
      spreadElement?: ReturnType<typeof SpreadElement.prototype.toObject>;
      property?: ReturnType<typeof Property.prototype.toObject>;
      assignmentPattern?: ReturnType<typeof AssignmentPattern.prototype.toObject>;
      restElement?: ReturnType<typeof RestElement.prototype.toObject>;
      arrayPattern?: ReturnType<typeof ArrayPattern.prototype.toObject>;
      objectPattern?: ReturnType<typeof ObjectPattern.prototype.toObject>;
      privateIdentifier?: ReturnType<typeof PrivateIdentifier.prototype.toObject>;
      newExpression?: ReturnType<typeof NewExpression.prototype.toObject>;
      super?: ReturnType<typeof Super.prototype.toObject>;
      metaProperty?: ReturnType<typeof MetaProperty.prototype.toObject>;
      memberExpression?: ReturnType<typeof MemberExpression.prototype.toObject>;
      logicalExpression?: ReturnType<typeof LogicalExpression.prototype.toObject>;
      importExpression?: ReturnType<typeof ImportExpression.prototype.toObject>;
      blockStatement?: ReturnType<typeof BlockStatement.prototype.toObject>;
      conditionalExpression?: ReturnType<typeof ConditionalExpression.prototype.toObject>;
      classExpression?: ReturnType<typeof ClassExpression.prototype.toObject>;
      classBody?: ReturnType<typeof ClassBody.prototype.toObject>;
      staticBlock?: ReturnType<typeof StaticBlock.prototype.toObject>;
      propertyDefinition?: ReturnType<typeof PropertyDefinition.prototype.toObject>;
      methodDefinition?: ReturnType<typeof MethodDefinition.prototype.toObject>;
      chainExpression?: ReturnType<typeof ChainExpression.prototype.toObject>;
      simpleCallExpression?: ReturnType<typeof SimpleCallExpression.prototype.toObject>;
      binaryExpression?: ReturnType<typeof BinaryExpression.prototype.toObject>;
      awaitExpression?: ReturnType<typeof AwaitExpression.prototype.toObject>;
      assignmentExpression?: ReturnType<typeof AssignmentExpression.prototype.toObject>;
      arrowFunctionExpression?: ReturnType<typeof ArrowFunctionExpression.prototype.toObject>;
      arrayExpression?: ReturnType<typeof ArrayExpression.prototype.toObject>;
      maybeNamedClassDeclaration?: ReturnType<typeof MaybeNamedClassDeclaration.prototype.toObject>;
      maybeNamedFunctionDeclaration?: ReturnType<
        typeof MaybeNamedFunctionDeclaration.prototype.toObject
      >;
      exportNamedDeclaration?: ReturnType<typeof ExportNamedDeclaration.prototype.toObject>;
      exportSpecifier?: ReturnType<typeof ExportSpecifier.prototype.toObject>;
      variableDeclaration?: ReturnType<typeof VariableDeclaration.prototype.toObject>;
      variableDeclarator?: ReturnType<typeof VariableDeclarator.prototype.toObject>;
      importDeclaration?: ReturnType<typeof ImportDeclaration.prototype.toObject>;
      importNamespaceSpecifier?: ReturnType<typeof ImportNamespaceSpecifier.prototype.toObject>;
      importDefaultSpecifier?: ReturnType<typeof ImportDefaultSpecifier.prototype.toObject>;
      importSpecifier?: ReturnType<typeof ImportSpecifier.prototype.toObject>;
      forOfStatement?: ReturnType<typeof ForOfStatement.prototype.toObject>;
      forInStatement?: ReturnType<typeof ForInStatement.prototype.toObject>;
      forStatement?: ReturnType<typeof ForStatement.prototype.toObject>;
      doWhileStatement?: ReturnType<typeof DoWhileStatement.prototype.toObject>;
      whileStatement?: ReturnType<typeof WhileStatement.prototype.toObject>;
      tryStatement?: ReturnType<typeof TryStatement.prototype.toObject>;
      catchClause?: ReturnType<typeof CatchClause.prototype.toObject>;
      throwStatement?: ReturnType<typeof ThrowStatement.prototype.toObject>;
      switchStatement?: ReturnType<typeof SwitchStatement.prototype.toObject>;
      switchCase?: ReturnType<typeof SwitchCase.prototype.toObject>;
      ifStatement?: ReturnType<typeof IfStatement.prototype.toObject>;
      continueStatement?: ReturnType<typeof ContinueStatement.prototype.toObject>;
      breakStatement?: ReturnType<typeof BreakStatement.prototype.toObject>;
      labeledStatement?: ReturnType<typeof LabeledStatement.prototype.toObject>;
      returnStatement?: ReturnType<typeof ReturnStatement.prototype.toObject>;
      withStatement?: ReturnType<typeof WithStatement.prototype.toObject>;
      debuggerStatement?: ReturnType<typeof DebuggerStatement.prototype.toObject>;
      emptyStatement?: ReturnType<typeof EmptyStatement.prototype.toObject>;
      expressionStatement?: ReturnType<typeof ExpressionStatement.prototype.toObject>;
      directive?: ReturnType<typeof Directive.prototype.toObject>;
      regExpLiteral?: ReturnType<typeof RegExpLiteral.prototype.toObject>;
      templateElement?: ReturnType<typeof TemplateElement.prototype.toObject>;
      functionExpression?: ReturnType<typeof FunctionExpression.prototype.toObject>;
    } = {};
    if (this.type != null) {
      data.type = this.type;
    }
    if (this.loc != null) {
      data.loc = this.loc.toObject();
    }
    if (this.program != null) {
      data.program = this.program.toObject();
    }
    if (this.exportAllDeclaration != null) {
      data.exportAllDeclaration = this.exportAllDeclaration.toObject();
    }
    if (this.bigIntLiteral != null) {
      data.bigIntLiteral = this.bigIntLiteral.toObject();
    }
    if (this.simpleLiteral != null) {
      data.simpleLiteral = this.simpleLiteral.toObject();
    }
    if (this.identifier != null) {
      data.identifier = this.identifier.toObject();
    }
    if (this.exportDefaultDeclaration != null) {
      data.exportDefaultDeclaration = this.exportDefaultDeclaration.toObject();
    }
    if (this.yieldExpression != null) {
      data.yieldExpression = this.yieldExpression.toObject();
    }
    if (this.updateExpression != null) {
      data.updateExpression = this.updateExpression.toObject();
    }
    if (this.unaryExpression != null) {
      data.unaryExpression = this.unaryExpression.toObject();
    }
    if (this.thisExpression != null) {
      data.thisExpression = this.thisExpression.toObject();
    }
    if (this.templateLiteral != null) {
      data.templateLiteral = this.templateLiteral.toObject();
    }
    if (this.taggedTemplateExpression != null) {
      data.taggedTemplateExpression = this.taggedTemplateExpression.toObject();
    }
    if (this.sequenceExpression != null) {
      data.sequenceExpression = this.sequenceExpression.toObject();
    }
    if (this.objectExpression != null) {
      data.objectExpression = this.objectExpression.toObject();
    }
    if (this.spreadElement != null) {
      data.spreadElement = this.spreadElement.toObject();
    }
    if (this.property != null) {
      data.property = this.property.toObject();
    }
    if (this.assignmentPattern != null) {
      data.assignmentPattern = this.assignmentPattern.toObject();
    }
    if (this.restElement != null) {
      data.restElement = this.restElement.toObject();
    }
    if (this.arrayPattern != null) {
      data.arrayPattern = this.arrayPattern.toObject();
    }
    if (this.objectPattern != null) {
      data.objectPattern = this.objectPattern.toObject();
    }
    if (this.privateIdentifier != null) {
      data.privateIdentifier = this.privateIdentifier.toObject();
    }
    if (this.newExpression != null) {
      data.newExpression = this.newExpression.toObject();
    }
    if (this.super != null) {
      data.super = this.super.toObject();
    }
    if (this.metaProperty != null) {
      data.metaProperty = this.metaProperty.toObject();
    }
    if (this.memberExpression != null) {
      data.memberExpression = this.memberExpression.toObject();
    }
    if (this.logicalExpression != null) {
      data.logicalExpression = this.logicalExpression.toObject();
    }
    if (this.importExpression != null) {
      data.importExpression = this.importExpression.toObject();
    }
    if (this.blockStatement != null) {
      data.blockStatement = this.blockStatement.toObject();
    }
    if (this.conditionalExpression != null) {
      data.conditionalExpression = this.conditionalExpression.toObject();
    }
    if (this.classExpression != null) {
      data.classExpression = this.classExpression.toObject();
    }
    if (this.classBody != null) {
      data.classBody = this.classBody.toObject();
    }
    if (this.staticBlock != null) {
      data.staticBlock = this.staticBlock.toObject();
    }
    if (this.propertyDefinition != null) {
      data.propertyDefinition = this.propertyDefinition.toObject();
    }
    if (this.methodDefinition != null) {
      data.methodDefinition = this.methodDefinition.toObject();
    }
    if (this.chainExpression != null) {
      data.chainExpression = this.chainExpression.toObject();
    }
    if (this.simpleCallExpression != null) {
      data.simpleCallExpression = this.simpleCallExpression.toObject();
    }
    if (this.binaryExpression != null) {
      data.binaryExpression = this.binaryExpression.toObject();
    }
    if (this.awaitExpression != null) {
      data.awaitExpression = this.awaitExpression.toObject();
    }
    if (this.assignmentExpression != null) {
      data.assignmentExpression = this.assignmentExpression.toObject();
    }
    if (this.arrowFunctionExpression != null) {
      data.arrowFunctionExpression = this.arrowFunctionExpression.toObject();
    }
    if (this.arrayExpression != null) {
      data.arrayExpression = this.arrayExpression.toObject();
    }
    if (this.maybeNamedClassDeclaration != null) {
      data.maybeNamedClassDeclaration = this.maybeNamedClassDeclaration.toObject();
    }
    if (this.maybeNamedFunctionDeclaration != null) {
      data.maybeNamedFunctionDeclaration = this.maybeNamedFunctionDeclaration.toObject();
    }
    if (this.exportNamedDeclaration != null) {
      data.exportNamedDeclaration = this.exportNamedDeclaration.toObject();
    }
    if (this.exportSpecifier != null) {
      data.exportSpecifier = this.exportSpecifier.toObject();
    }
    if (this.variableDeclaration != null) {
      data.variableDeclaration = this.variableDeclaration.toObject();
    }
    if (this.variableDeclarator != null) {
      data.variableDeclarator = this.variableDeclarator.toObject();
    }
    if (this.importDeclaration != null) {
      data.importDeclaration = this.importDeclaration.toObject();
    }
    if (this.importNamespaceSpecifier != null) {
      data.importNamespaceSpecifier = this.importNamespaceSpecifier.toObject();
    }
    if (this.importDefaultSpecifier != null) {
      data.importDefaultSpecifier = this.importDefaultSpecifier.toObject();
    }
    if (this.importSpecifier != null) {
      data.importSpecifier = this.importSpecifier.toObject();
    }
    if (this.forOfStatement != null) {
      data.forOfStatement = this.forOfStatement.toObject();
    }
    if (this.forInStatement != null) {
      data.forInStatement = this.forInStatement.toObject();
    }
    if (this.forStatement != null) {
      data.forStatement = this.forStatement.toObject();
    }
    if (this.doWhileStatement != null) {
      data.doWhileStatement = this.doWhileStatement.toObject();
    }
    if (this.whileStatement != null) {
      data.whileStatement = this.whileStatement.toObject();
    }
    if (this.tryStatement != null) {
      data.tryStatement = this.tryStatement.toObject();
    }
    if (this.catchClause != null) {
      data.catchClause = this.catchClause.toObject();
    }
    if (this.throwStatement != null) {
      data.throwStatement = this.throwStatement.toObject();
    }
    if (this.switchStatement != null) {
      data.switchStatement = this.switchStatement.toObject();
    }
    if (this.switchCase != null) {
      data.switchCase = this.switchCase.toObject();
    }
    if (this.ifStatement != null) {
      data.ifStatement = this.ifStatement.toObject();
    }
    if (this.continueStatement != null) {
      data.continueStatement = this.continueStatement.toObject();
    }
    if (this.breakStatement != null) {
      data.breakStatement = this.breakStatement.toObject();
    }
    if (this.labeledStatement != null) {
      data.labeledStatement = this.labeledStatement.toObject();
    }
    if (this.returnStatement != null) {
      data.returnStatement = this.returnStatement.toObject();
    }
    if (this.withStatement != null) {
      data.withStatement = this.withStatement.toObject();
    }
    if (this.debuggerStatement != null) {
      data.debuggerStatement = this.debuggerStatement.toObject();
    }
    if (this.emptyStatement != null) {
      data.emptyStatement = this.emptyStatement.toObject();
    }
    if (this.expressionStatement != null) {
      data.expressionStatement = this.expressionStatement.toObject();
    }
    if (this.directive != null) {
      data.directive = this.directive.toObject();
    }
    if (this.regExpLiteral != null) {
      data.regExpLiteral = this.regExpLiteral.toObject();
    }
    if (this.templateElement != null) {
      data.templateElement = this.templateElement.toObject();
    }
    if (this.functionExpression != null) {
      data.functionExpression = this.functionExpression.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.type != NodeType.ProgramType) writer.writeEnum(1, this.type);
    if (this.has_loc) writer.writeMessage(2, this.loc, () => this.loc.serialize(writer));
    if (this.has_program)
      writer.writeMessage(3, this.program, () => this.program.serialize(writer));
    if (this.has_exportAllDeclaration)
      writer.writeMessage(4, this.exportAllDeclaration, () =>
        this.exportAllDeclaration.serialize(writer),
      );
    if (this.has_bigIntLiteral)
      writer.writeMessage(5, this.bigIntLiteral, () => this.bigIntLiteral.serialize(writer));
    if (this.has_simpleLiteral)
      writer.writeMessage(6, this.simpleLiteral, () => this.simpleLiteral.serialize(writer));
    if (this.has_identifier)
      writer.writeMessage(7, this.identifier, () => this.identifier.serialize(writer));
    if (this.has_exportDefaultDeclaration)
      writer.writeMessage(8, this.exportDefaultDeclaration, () =>
        this.exportDefaultDeclaration.serialize(writer),
      );
    if (this.has_yieldExpression)
      writer.writeMessage(9, this.yieldExpression, () => this.yieldExpression.serialize(writer));
    if (this.has_updateExpression)
      writer.writeMessage(10, this.updateExpression, () => this.updateExpression.serialize(writer));
    if (this.has_unaryExpression)
      writer.writeMessage(11, this.unaryExpression, () => this.unaryExpression.serialize(writer));
    if (this.has_thisExpression)
      writer.writeMessage(12, this.thisExpression, () => this.thisExpression.serialize(writer));
    if (this.has_templateLiteral)
      writer.writeMessage(13, this.templateLiteral, () => this.templateLiteral.serialize(writer));
    if (this.has_taggedTemplateExpression)
      writer.writeMessage(14, this.taggedTemplateExpression, () =>
        this.taggedTemplateExpression.serialize(writer),
      );
    if (this.has_sequenceExpression)
      writer.writeMessage(15, this.sequenceExpression, () =>
        this.sequenceExpression.serialize(writer),
      );
    if (this.has_objectExpression)
      writer.writeMessage(16, this.objectExpression, () => this.objectExpression.serialize(writer));
    if (this.has_spreadElement)
      writer.writeMessage(17, this.spreadElement, () => this.spreadElement.serialize(writer));
    if (this.has_property)
      writer.writeMessage(18, this.property, () => this.property.serialize(writer));
    if (this.has_assignmentPattern)
      writer.writeMessage(19, this.assignmentPattern, () =>
        this.assignmentPattern.serialize(writer),
      );
    if (this.has_restElement)
      writer.writeMessage(20, this.restElement, () => this.restElement.serialize(writer));
    if (this.has_arrayPattern)
      writer.writeMessage(21, this.arrayPattern, () => this.arrayPattern.serialize(writer));
    if (this.has_objectPattern)
      writer.writeMessage(22, this.objectPattern, () => this.objectPattern.serialize(writer));
    if (this.has_privateIdentifier)
      writer.writeMessage(23, this.privateIdentifier, () =>
        this.privateIdentifier.serialize(writer),
      );
    if (this.has_newExpression)
      writer.writeMessage(24, this.newExpression, () => this.newExpression.serialize(writer));
    if (this.has_super) writer.writeMessage(25, this.super, () => this.super.serialize(writer));
    if (this.has_metaProperty)
      writer.writeMessage(26, this.metaProperty, () => this.metaProperty.serialize(writer));
    if (this.has_memberExpression)
      writer.writeMessage(27, this.memberExpression, () => this.memberExpression.serialize(writer));
    if (this.has_logicalExpression)
      writer.writeMessage(28, this.logicalExpression, () =>
        this.logicalExpression.serialize(writer),
      );
    if (this.has_importExpression)
      writer.writeMessage(29, this.importExpression, () => this.importExpression.serialize(writer));
    if (this.has_blockStatement)
      writer.writeMessage(30, this.blockStatement, () => this.blockStatement.serialize(writer));
    if (this.has_conditionalExpression)
      writer.writeMessage(31, this.conditionalExpression, () =>
        this.conditionalExpression.serialize(writer),
      );
    if (this.has_classExpression)
      writer.writeMessage(32, this.classExpression, () => this.classExpression.serialize(writer));
    if (this.has_classBody)
      writer.writeMessage(33, this.classBody, () => this.classBody.serialize(writer));
    if (this.has_staticBlock)
      writer.writeMessage(34, this.staticBlock, () => this.staticBlock.serialize(writer));
    if (this.has_propertyDefinition)
      writer.writeMessage(35, this.propertyDefinition, () =>
        this.propertyDefinition.serialize(writer),
      );
    if (this.has_methodDefinition)
      writer.writeMessage(36, this.methodDefinition, () => this.methodDefinition.serialize(writer));
    if (this.has_chainExpression)
      writer.writeMessage(37, this.chainExpression, () => this.chainExpression.serialize(writer));
    if (this.has_simpleCallExpression)
      writer.writeMessage(38, this.simpleCallExpression, () =>
        this.simpleCallExpression.serialize(writer),
      );
    if (this.has_binaryExpression)
      writer.writeMessage(39, this.binaryExpression, () => this.binaryExpression.serialize(writer));
    if (this.has_awaitExpression)
      writer.writeMessage(40, this.awaitExpression, () => this.awaitExpression.serialize(writer));
    if (this.has_assignmentExpression)
      writer.writeMessage(41, this.assignmentExpression, () =>
        this.assignmentExpression.serialize(writer),
      );
    if (this.has_arrowFunctionExpression)
      writer.writeMessage(42, this.arrowFunctionExpression, () =>
        this.arrowFunctionExpression.serialize(writer),
      );
    if (this.has_arrayExpression)
      writer.writeMessage(43, this.arrayExpression, () => this.arrayExpression.serialize(writer));
    if (this.has_maybeNamedClassDeclaration)
      writer.writeMessage(44, this.maybeNamedClassDeclaration, () =>
        this.maybeNamedClassDeclaration.serialize(writer),
      );
    if (this.has_maybeNamedFunctionDeclaration)
      writer.writeMessage(45, this.maybeNamedFunctionDeclaration, () =>
        this.maybeNamedFunctionDeclaration.serialize(writer),
      );
    if (this.has_exportNamedDeclaration)
      writer.writeMessage(46, this.exportNamedDeclaration, () =>
        this.exportNamedDeclaration.serialize(writer),
      );
    if (this.has_exportSpecifier)
      writer.writeMessage(47, this.exportSpecifier, () => this.exportSpecifier.serialize(writer));
    if (this.has_variableDeclaration)
      writer.writeMessage(48, this.variableDeclaration, () =>
        this.variableDeclaration.serialize(writer),
      );
    if (this.has_variableDeclarator)
      writer.writeMessage(49, this.variableDeclarator, () =>
        this.variableDeclarator.serialize(writer),
      );
    if (this.has_importDeclaration)
      writer.writeMessage(50, this.importDeclaration, () =>
        this.importDeclaration.serialize(writer),
      );
    if (this.has_importNamespaceSpecifier)
      writer.writeMessage(51, this.importNamespaceSpecifier, () =>
        this.importNamespaceSpecifier.serialize(writer),
      );
    if (this.has_importDefaultSpecifier)
      writer.writeMessage(52, this.importDefaultSpecifier, () =>
        this.importDefaultSpecifier.serialize(writer),
      );
    if (this.has_importSpecifier)
      writer.writeMessage(53, this.importSpecifier, () => this.importSpecifier.serialize(writer));
    if (this.has_forOfStatement)
      writer.writeMessage(54, this.forOfStatement, () => this.forOfStatement.serialize(writer));
    if (this.has_forInStatement)
      writer.writeMessage(55, this.forInStatement, () => this.forInStatement.serialize(writer));
    if (this.has_forStatement)
      writer.writeMessage(56, this.forStatement, () => this.forStatement.serialize(writer));
    if (this.has_doWhileStatement)
      writer.writeMessage(57, this.doWhileStatement, () => this.doWhileStatement.serialize(writer));
    if (this.has_whileStatement)
      writer.writeMessage(58, this.whileStatement, () => this.whileStatement.serialize(writer));
    if (this.has_tryStatement)
      writer.writeMessage(59, this.tryStatement, () => this.tryStatement.serialize(writer));
    if (this.has_catchClause)
      writer.writeMessage(60, this.catchClause, () => this.catchClause.serialize(writer));
    if (this.has_throwStatement)
      writer.writeMessage(61, this.throwStatement, () => this.throwStatement.serialize(writer));
    if (this.has_switchStatement)
      writer.writeMessage(62, this.switchStatement, () => this.switchStatement.serialize(writer));
    if (this.has_switchCase)
      writer.writeMessage(63, this.switchCase, () => this.switchCase.serialize(writer));
    if (this.has_ifStatement)
      writer.writeMessage(64, this.ifStatement, () => this.ifStatement.serialize(writer));
    if (this.has_continueStatement)
      writer.writeMessage(65, this.continueStatement, () =>
        this.continueStatement.serialize(writer),
      );
    if (this.has_breakStatement)
      writer.writeMessage(66, this.breakStatement, () => this.breakStatement.serialize(writer));
    if (this.has_labeledStatement)
      writer.writeMessage(67, this.labeledStatement, () => this.labeledStatement.serialize(writer));
    if (this.has_returnStatement)
      writer.writeMessage(68, this.returnStatement, () => this.returnStatement.serialize(writer));
    if (this.has_withStatement)
      writer.writeMessage(69, this.withStatement, () => this.withStatement.serialize(writer));
    if (this.has_debuggerStatement)
      writer.writeMessage(70, this.debuggerStatement, () =>
        this.debuggerStatement.serialize(writer),
      );
    if (this.has_emptyStatement)
      writer.writeMessage(71, this.emptyStatement, () => this.emptyStatement.serialize(writer));
    if (this.has_expressionStatement)
      writer.writeMessage(72, this.expressionStatement, () =>
        this.expressionStatement.serialize(writer),
      );
    if (this.has_directive)
      writer.writeMessage(73, this.directive, () => this.directive.serialize(writer));
    if (this.has_regExpLiteral)
      writer.writeMessage(74, this.regExpLiteral, () => this.regExpLiteral.serialize(writer));
    if (this.has_templateElement)
      writer.writeMessage(75, this.templateElement, () => this.templateElement.serialize(writer));
    if (this.has_functionExpression)
      writer.writeMessage(76, this.functionExpression, () =>
        this.functionExpression.serialize(writer),
      );
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Node {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Node();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.type = reader.readEnum();
          break;
        case 2:
          reader.readMessage(message.loc, () => (message.loc = SourceLocation.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(
            message.program,
            () => (message.program = Program.deserialize(reader)),
          );
          break;
        case 4:
          reader.readMessage(
            message.exportAllDeclaration,
            () => (message.exportAllDeclaration = ExportAllDeclaration.deserialize(reader)),
          );
          break;
        case 5:
          reader.readMessage(
            message.bigIntLiteral,
            () => (message.bigIntLiteral = BigIntLiteral.deserialize(reader)),
          );
          break;
        case 6:
          reader.readMessage(
            message.simpleLiteral,
            () => (message.simpleLiteral = SimpleLiteral.deserialize(reader)),
          );
          break;
        case 7:
          reader.readMessage(
            message.identifier,
            () => (message.identifier = Identifier.deserialize(reader)),
          );
          break;
        case 8:
          reader.readMessage(
            message.exportDefaultDeclaration,
            () => (message.exportDefaultDeclaration = ExportDefaultDeclaration.deserialize(reader)),
          );
          break;
        case 9:
          reader.readMessage(
            message.yieldExpression,
            () => (message.yieldExpression = YieldExpression.deserialize(reader)),
          );
          break;
        case 10:
          reader.readMessage(
            message.updateExpression,
            () => (message.updateExpression = UpdateExpression.deserialize(reader)),
          );
          break;
        case 11:
          reader.readMessage(
            message.unaryExpression,
            () => (message.unaryExpression = UnaryExpression.deserialize(reader)),
          );
          break;
        case 12:
          reader.readMessage(
            message.thisExpression,
            () => (message.thisExpression = ThisExpression.deserialize(reader)),
          );
          break;
        case 13:
          reader.readMessage(
            message.templateLiteral,
            () => (message.templateLiteral = TemplateLiteral.deserialize(reader)),
          );
          break;
        case 14:
          reader.readMessage(
            message.taggedTemplateExpression,
            () => (message.taggedTemplateExpression = TaggedTemplateExpression.deserialize(reader)),
          );
          break;
        case 15:
          reader.readMessage(
            message.sequenceExpression,
            () => (message.sequenceExpression = SequenceExpression.deserialize(reader)),
          );
          break;
        case 16:
          reader.readMessage(
            message.objectExpression,
            () => (message.objectExpression = ObjectExpression.deserialize(reader)),
          );
          break;
        case 17:
          reader.readMessage(
            message.spreadElement,
            () => (message.spreadElement = SpreadElement.deserialize(reader)),
          );
          break;
        case 18:
          reader.readMessage(
            message.property,
            () => (message.property = Property.deserialize(reader)),
          );
          break;
        case 19:
          reader.readMessage(
            message.assignmentPattern,
            () => (message.assignmentPattern = AssignmentPattern.deserialize(reader)),
          );
          break;
        case 20:
          reader.readMessage(
            message.restElement,
            () => (message.restElement = RestElement.deserialize(reader)),
          );
          break;
        case 21:
          reader.readMessage(
            message.arrayPattern,
            () => (message.arrayPattern = ArrayPattern.deserialize(reader)),
          );
          break;
        case 22:
          reader.readMessage(
            message.objectPattern,
            () => (message.objectPattern = ObjectPattern.deserialize(reader)),
          );
          break;
        case 23:
          reader.readMessage(
            message.privateIdentifier,
            () => (message.privateIdentifier = PrivateIdentifier.deserialize(reader)),
          );
          break;
        case 24:
          reader.readMessage(
            message.newExpression,
            () => (message.newExpression = NewExpression.deserialize(reader)),
          );
          break;
        case 25:
          reader.readMessage(message.super, () => (message.super = Super.deserialize(reader)));
          break;
        case 26:
          reader.readMessage(
            message.metaProperty,
            () => (message.metaProperty = MetaProperty.deserialize(reader)),
          );
          break;
        case 27:
          reader.readMessage(
            message.memberExpression,
            () => (message.memberExpression = MemberExpression.deserialize(reader)),
          );
          break;
        case 28:
          reader.readMessage(
            message.logicalExpression,
            () => (message.logicalExpression = LogicalExpression.deserialize(reader)),
          );
          break;
        case 29:
          reader.readMessage(
            message.importExpression,
            () => (message.importExpression = ImportExpression.deserialize(reader)),
          );
          break;
        case 30:
          reader.readMessage(
            message.blockStatement,
            () => (message.blockStatement = BlockStatement.deserialize(reader)),
          );
          break;
        case 31:
          reader.readMessage(
            message.conditionalExpression,
            () => (message.conditionalExpression = ConditionalExpression.deserialize(reader)),
          );
          break;
        case 32:
          reader.readMessage(
            message.classExpression,
            () => (message.classExpression = ClassExpression.deserialize(reader)),
          );
          break;
        case 33:
          reader.readMessage(
            message.classBody,
            () => (message.classBody = ClassBody.deserialize(reader)),
          );
          break;
        case 34:
          reader.readMessage(
            message.staticBlock,
            () => (message.staticBlock = StaticBlock.deserialize(reader)),
          );
          break;
        case 35:
          reader.readMessage(
            message.propertyDefinition,
            () => (message.propertyDefinition = PropertyDefinition.deserialize(reader)),
          );
          break;
        case 36:
          reader.readMessage(
            message.methodDefinition,
            () => (message.methodDefinition = MethodDefinition.deserialize(reader)),
          );
          break;
        case 37:
          reader.readMessage(
            message.chainExpression,
            () => (message.chainExpression = ChainExpression.deserialize(reader)),
          );
          break;
        case 38:
          reader.readMessage(
            message.simpleCallExpression,
            () => (message.simpleCallExpression = SimpleCallExpression.deserialize(reader)),
          );
          break;
        case 39:
          reader.readMessage(
            message.binaryExpression,
            () => (message.binaryExpression = BinaryExpression.deserialize(reader)),
          );
          break;
        case 40:
          reader.readMessage(
            message.awaitExpression,
            () => (message.awaitExpression = AwaitExpression.deserialize(reader)),
          );
          break;
        case 41:
          reader.readMessage(
            message.assignmentExpression,
            () => (message.assignmentExpression = AssignmentExpression.deserialize(reader)),
          );
          break;
        case 42:
          reader.readMessage(
            message.arrowFunctionExpression,
            () => (message.arrowFunctionExpression = ArrowFunctionExpression.deserialize(reader)),
          );
          break;
        case 43:
          reader.readMessage(
            message.arrayExpression,
            () => (message.arrayExpression = ArrayExpression.deserialize(reader)),
          );
          break;
        case 44:
          reader.readMessage(
            message.maybeNamedClassDeclaration,
            () =>
              (message.maybeNamedClassDeclaration = MaybeNamedClassDeclaration.deserialize(reader)),
          );
          break;
        case 45:
          reader.readMessage(
            message.maybeNamedFunctionDeclaration,
            () =>
              (message.maybeNamedFunctionDeclaration =
                MaybeNamedFunctionDeclaration.deserialize(reader)),
          );
          break;
        case 46:
          reader.readMessage(
            message.exportNamedDeclaration,
            () => (message.exportNamedDeclaration = ExportNamedDeclaration.deserialize(reader)),
          );
          break;
        case 47:
          reader.readMessage(
            message.exportSpecifier,
            () => (message.exportSpecifier = ExportSpecifier.deserialize(reader)),
          );
          break;
        case 48:
          reader.readMessage(
            message.variableDeclaration,
            () => (message.variableDeclaration = VariableDeclaration.deserialize(reader)),
          );
          break;
        case 49:
          reader.readMessage(
            message.variableDeclarator,
            () => (message.variableDeclarator = VariableDeclarator.deserialize(reader)),
          );
          break;
        case 50:
          reader.readMessage(
            message.importDeclaration,
            () => (message.importDeclaration = ImportDeclaration.deserialize(reader)),
          );
          break;
        case 51:
          reader.readMessage(
            message.importNamespaceSpecifier,
            () => (message.importNamespaceSpecifier = ImportNamespaceSpecifier.deserialize(reader)),
          );
          break;
        case 52:
          reader.readMessage(
            message.importDefaultSpecifier,
            () => (message.importDefaultSpecifier = ImportDefaultSpecifier.deserialize(reader)),
          );
          break;
        case 53:
          reader.readMessage(
            message.importSpecifier,
            () => (message.importSpecifier = ImportSpecifier.deserialize(reader)),
          );
          break;
        case 54:
          reader.readMessage(
            message.forOfStatement,
            () => (message.forOfStatement = ForOfStatement.deserialize(reader)),
          );
          break;
        case 55:
          reader.readMessage(
            message.forInStatement,
            () => (message.forInStatement = ForInStatement.deserialize(reader)),
          );
          break;
        case 56:
          reader.readMessage(
            message.forStatement,
            () => (message.forStatement = ForStatement.deserialize(reader)),
          );
          break;
        case 57:
          reader.readMessage(
            message.doWhileStatement,
            () => (message.doWhileStatement = DoWhileStatement.deserialize(reader)),
          );
          break;
        case 58:
          reader.readMessage(
            message.whileStatement,
            () => (message.whileStatement = WhileStatement.deserialize(reader)),
          );
          break;
        case 59:
          reader.readMessage(
            message.tryStatement,
            () => (message.tryStatement = TryStatement.deserialize(reader)),
          );
          break;
        case 60:
          reader.readMessage(
            message.catchClause,
            () => (message.catchClause = CatchClause.deserialize(reader)),
          );
          break;
        case 61:
          reader.readMessage(
            message.throwStatement,
            () => (message.throwStatement = ThrowStatement.deserialize(reader)),
          );
          break;
        case 62:
          reader.readMessage(
            message.switchStatement,
            () => (message.switchStatement = SwitchStatement.deserialize(reader)),
          );
          break;
        case 63:
          reader.readMessage(
            message.switchCase,
            () => (message.switchCase = SwitchCase.deserialize(reader)),
          );
          break;
        case 64:
          reader.readMessage(
            message.ifStatement,
            () => (message.ifStatement = IfStatement.deserialize(reader)),
          );
          break;
        case 65:
          reader.readMessage(
            message.continueStatement,
            () => (message.continueStatement = ContinueStatement.deserialize(reader)),
          );
          break;
        case 66:
          reader.readMessage(
            message.breakStatement,
            () => (message.breakStatement = BreakStatement.deserialize(reader)),
          );
          break;
        case 67:
          reader.readMessage(
            message.labeledStatement,
            () => (message.labeledStatement = LabeledStatement.deserialize(reader)),
          );
          break;
        case 68:
          reader.readMessage(
            message.returnStatement,
            () => (message.returnStatement = ReturnStatement.deserialize(reader)),
          );
          break;
        case 69:
          reader.readMessage(
            message.withStatement,
            () => (message.withStatement = WithStatement.deserialize(reader)),
          );
          break;
        case 70:
          reader.readMessage(
            message.debuggerStatement,
            () => (message.debuggerStatement = DebuggerStatement.deserialize(reader)),
          );
          break;
        case 71:
          reader.readMessage(
            message.emptyStatement,
            () => (message.emptyStatement = EmptyStatement.deserialize(reader)),
          );
          break;
        case 72:
          reader.readMessage(
            message.expressionStatement,
            () => (message.expressionStatement = ExpressionStatement.deserialize(reader)),
          );
          break;
        case 73:
          reader.readMessage(
            message.directive,
            () => (message.directive = Directive.deserialize(reader)),
          );
          break;
        case 74:
          reader.readMessage(
            message.regExpLiteral,
            () => (message.regExpLiteral = RegExpLiteral.deserialize(reader)),
          );
          break;
        case 75:
          reader.readMessage(
            message.templateElement,
            () => (message.templateElement = TemplateElement.deserialize(reader)),
          );
          break;
        case 76:
          reader.readMessage(
            message.functionExpression,
            () => (message.functionExpression = FunctionExpression.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Node {
    return Node.deserialize(bytes);
  }
}
export class Program extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          sourceType?: string;
          body?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('sourceType' in data && data.sourceType != undefined) {
        this.sourceType = data.sourceType;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get sourceType() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set sourceType(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get body() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set body(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    sourceType?: string;
    body?: ReturnType<typeof Node.prototype.toObject>[];
  }): Program {
    const message = new Program({});
    if (data.sourceType != null) {
      message.sourceType = data.sourceType;
    }
    if (data.body != null) {
      message.body = data.body.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      sourceType?: string;
      body?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.sourceType != null) {
      data.sourceType = this.sourceType;
    }
    if (this.body != null) {
      data.body = this.body.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.sourceType.length) writer.writeString(1, this.sourceType);
    if (this.body.length)
      writer.writeRepeatedMessage(2, this.body, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Program {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Program();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.sourceType = reader.readString();
          break;
        case 2:
          reader.readMessage(message.body, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Program {
    return Program.deserialize(bytes);
  }
}
export class ExportAllDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          exported?: Node;
          source?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('exported' in data && data.exported != undefined) {
        this.exported = data.exported;
      }
      if ('source' in data && data.source != undefined) {
        this.source = data.source;
      }
    }
  }
  get exported() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set exported(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_exported() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get source() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set source(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_source() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    exported?: ReturnType<typeof Node.prototype.toObject>;
    source?: ReturnType<typeof Node.prototype.toObject>;
  }): ExportAllDeclaration {
    const message = new ExportAllDeclaration({});
    if (data.exported != null) {
      message.exported = Node.fromObject(data.exported);
    }
    if (data.source != null) {
      message.source = Node.fromObject(data.source);
    }
    return message;
  }
  toObject() {
    const data: {
      exported?: ReturnType<typeof Node.prototype.toObject>;
      source?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.exported != null) {
      data.exported = this.exported.toObject();
    }
    if (this.source != null) {
      data.source = this.source.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_exported)
      writer.writeMessage(1, this.exported, () => this.exported.serialize(writer));
    if (this.has_source) writer.writeMessage(2, this.source, () => this.source.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExportAllDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ExportAllDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.exported, () => (message.exported = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.source, () => (message.source = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ExportAllDeclaration {
    return ExportAllDeclaration.deserialize(bytes);
  }
}
export class BigIntLiteral extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          value?: number;
          bigint?: string;
          raw?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('value' in data && data.value != undefined) {
        this.value = data.value;
      }
      if ('bigint' in data && data.bigint != undefined) {
        this.bigint = data.bigint;
      }
      if ('raw' in data && data.raw != undefined) {
        this.raw = data.raw;
      }
    }
  }
  get value() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set value(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get bigint() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set bigint(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  get raw() {
    return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
  }
  set raw(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  static fromObject(data: { value?: number; bigint?: string; raw?: string }): BigIntLiteral {
    const message = new BigIntLiteral({});
    if (data.value != null) {
      message.value = data.value;
    }
    if (data.bigint != null) {
      message.bigint = data.bigint;
    }
    if (data.raw != null) {
      message.raw = data.raw;
    }
    return message;
  }
  toObject() {
    const data: {
      value?: number;
      bigint?: string;
      raw?: string;
    } = {};
    if (this.value != null) {
      data.value = this.value;
    }
    if (this.bigint != null) {
      data.bigint = this.bigint;
    }
    if (this.raw != null) {
      data.raw = this.raw;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.value != 0) writer.writeInt32(1, this.value);
    if (this.bigint.length) writer.writeString(2, this.bigint);
    if (this.raw.length) writer.writeString(3, this.raw);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BigIntLiteral {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new BigIntLiteral();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.value = reader.readInt32();
          break;
        case 2:
          message.bigint = reader.readString();
          break;
        case 3:
          message.raw = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): BigIntLiteral {
    return BigIntLiteral.deserialize(bytes);
  }
}
export class SimpleLiteral extends pb_1.Message {
  #one_of_decls: number[][] = [[1, 2, 3]];
  constructor(
    data?:
      | any[]
      | ({
          raw?: string;
        } & (
          | {
              value_string?: string;
              value_boolean?: never;
              value_number?: never;
            }
          | {
              value_string?: never;
              value_boolean?: boolean;
              value_number?: never;
            }
          | {
              value_string?: never;
              value_boolean?: never;
              value_number?: number;
            }
        )),
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('value_string' in data && data.value_string != undefined) {
        this.value_string = data.value_string;
      }
      if ('value_boolean' in data && data.value_boolean != undefined) {
        this.value_boolean = data.value_boolean;
      }
      if ('value_number' in data && data.value_number != undefined) {
        this.value_number = data.value_number;
      }
      if ('raw' in data && data.raw != undefined) {
        this.raw = data.raw;
      }
    }
  }
  get value_string() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set value_string(value: string) {
    pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
  }
  get has_value_string() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get value_boolean() {
    return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
  }
  set value_boolean(value: boolean) {
    pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
  }
  get has_value_boolean() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get value_number() {
    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
  }
  set value_number(value: number) {
    pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
  }
  get has_value_number() {
    return pb_1.Message.getField(this, 3) != null;
  }
  get raw() {
    return pb_1.Message.getFieldWithDefault(this, 4, '') as string;
  }
  set raw(value: string) {
    pb_1.Message.setField(this, 4, value);
  }
  get value() {
    const cases: {
      [index: number]: 'none' | 'value_string' | 'value_boolean' | 'value_number';
    } = {
      0: 'none',
      1: 'value_string',
      2: 'value_boolean',
      3: 'value_number',
    };
    return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
  }
  static fromObject(data: {
    value_string?: string;
    value_boolean?: boolean;
    value_number?: number;
    raw?: string;
  }): SimpleLiteral {
    const message = new SimpleLiteral({});
    if (data.value_string != null) {
      message.value_string = data.value_string;
    }
    if (data.value_boolean != null) {
      message.value_boolean = data.value_boolean;
    }
    if (data.value_number != null) {
      message.value_number = data.value_number;
    }
    if (data.raw != null) {
      message.raw = data.raw;
    }
    return message;
  }
  toObject() {
    const data: {
      value_string?: string;
      value_boolean?: boolean;
      value_number?: number;
      raw?: string;
    } = {};
    if (this.value_string != null) {
      data.value_string = this.value_string;
    }
    if (this.value_boolean != null) {
      data.value_boolean = this.value_boolean;
    }
    if (this.value_number != null) {
      data.value_number = this.value_number;
    }
    if (this.raw != null) {
      data.raw = this.raw;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_value_string) writer.writeString(1, this.value_string);
    if (this.has_value_boolean) writer.writeBool(2, this.value_boolean);
    if (this.has_value_number) writer.writeInt32(3, this.value_number);
    if (this.raw.length) writer.writeString(4, this.raw);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimpleLiteral {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SimpleLiteral();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.value_string = reader.readString();
          break;
        case 2:
          message.value_boolean = reader.readBool();
          break;
        case 3:
          message.value_number = reader.readInt32();
          break;
        case 4:
          message.raw = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SimpleLiteral {
    return SimpleLiteral.deserialize(bytes);
  }
}
export class Identifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          name?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('name' in data && data.name != undefined) {
        this.name = data.name;
      }
    }
  }
  get name() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set name(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  static fromObject(data: { name?: string }): Identifier {
    const message = new Identifier({});
    if (data.name != null) {
      message.name = data.name;
    }
    return message;
  }
  toObject() {
    const data: {
      name?: string;
    } = {};
    if (this.name != null) {
      data.name = this.name;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.name.length) writer.writeString(1, this.name);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Identifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Identifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.name = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Identifier {
    return Identifier.deserialize(bytes);
  }
}
export class ExportDefaultDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          declaration?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('declaration' in data && data.declaration != undefined) {
        this.declaration = data.declaration;
      }
    }
  }
  get declaration() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set declaration(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_declaration() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    declaration?: ReturnType<typeof Node.prototype.toObject>;
  }): ExportDefaultDeclaration {
    const message = new ExportDefaultDeclaration({});
    if (data.declaration != null) {
      message.declaration = Node.fromObject(data.declaration);
    }
    return message;
  }
  toObject() {
    const data: {
      declaration?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.declaration != null) {
      data.declaration = this.declaration.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_declaration)
      writer.writeMessage(1, this.declaration, () => this.declaration.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExportDefaultDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ExportDefaultDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.declaration,
            () => (message.declaration = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ExportDefaultDeclaration {
    return ExportDefaultDeclaration.deserialize(bytes);
  }
}
export class YieldExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
          delegate?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
      if ('delegate' in data && data.delegate != undefined) {
        this.delegate = data.delegate;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get delegate() {
    return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
  }
  set delegate(value: boolean) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: {
    argument?: ReturnType<typeof Node.prototype.toObject>;
    delegate?: boolean;
  }): YieldExpression {
    const message = new YieldExpression({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    if (data.delegate != null) {
      message.delegate = data.delegate;
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
      delegate?: boolean;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    if (this.delegate != null) {
      data.delegate = this.delegate;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (this.delegate != false) writer.writeBool(2, this.delegate);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): YieldExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new YieldExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        case 2:
          message.delegate = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): YieldExpression {
    return YieldExpression.deserialize(bytes);
  }
}
export class UpdateExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          operator?: string;
          argument?: Node;
          prefix?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('operator' in data && data.operator != undefined) {
        this.operator = data.operator;
      }
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
      if ('prefix' in data && data.prefix != undefined) {
        this.prefix = data.prefix;
      }
    }
  }
  get operator() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set operator(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get prefix() {
    return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
  }
  set prefix(value: boolean) {
    pb_1.Message.setField(this, 3, value);
  }
  static fromObject(data: {
    operator?: string;
    argument?: ReturnType<typeof Node.prototype.toObject>;
    prefix?: boolean;
  }): UpdateExpression {
    const message = new UpdateExpression({});
    if (data.operator != null) {
      message.operator = data.operator;
    }
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    if (data.prefix != null) {
      message.prefix = data.prefix;
    }
    return message;
  }
  toObject() {
    const data: {
      operator?: string;
      argument?: ReturnType<typeof Node.prototype.toObject>;
      prefix?: boolean;
    } = {};
    if (this.operator != null) {
      data.operator = this.operator;
    }
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    if (this.prefix != null) {
      data.prefix = this.prefix;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.operator.length) writer.writeString(1, this.operator);
    if (this.has_argument)
      writer.writeMessage(2, this.argument, () => this.argument.serialize(writer));
    if (this.prefix != false) writer.writeBool(3, this.prefix);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new UpdateExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.operator = reader.readString();
          break;
        case 2:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        case 3:
          message.prefix = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): UpdateExpression {
    return UpdateExpression.deserialize(bytes);
  }
}
export class UnaryExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          operator?: string;
          prefix?: boolean;
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('operator' in data && data.operator != undefined) {
        this.operator = data.operator;
      }
      if ('prefix' in data && data.prefix != undefined) {
        this.prefix = data.prefix;
      }
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get operator() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set operator(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get prefix() {
    return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
  }
  set prefix(value: boolean) {
    pb_1.Message.setField(this, 2, value);
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    operator?: string;
    prefix?: boolean;
    argument?: ReturnType<typeof Node.prototype.toObject>;
  }): UnaryExpression {
    const message = new UnaryExpression({});
    if (data.operator != null) {
      message.operator = data.operator;
    }
    if (data.prefix != null) {
      message.prefix = data.prefix;
    }
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      operator?: string;
      prefix?: boolean;
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.operator != null) {
      data.operator = this.operator;
    }
    if (this.prefix != null) {
      data.prefix = this.prefix;
    }
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.operator.length) writer.writeString(1, this.operator);
    if (this.prefix != false) writer.writeBool(2, this.prefix);
    if (this.has_argument)
      writer.writeMessage(3, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnaryExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new UnaryExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.operator = reader.readString();
          break;
        case 2:
          message.prefix = reader.readBool();
          break;
        case 3:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): UnaryExpression {
    return UnaryExpression.deserialize(bytes);
  }
}
export class ThisExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(data?: any[] | {}) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
    }
  }
  static fromObject(data: {}): ThisExpression {
    const message = new ThisExpression({});
    return message;
  }
  toObject() {
    const data: {} = {};
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThisExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ThisExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ThisExpression {
    return ThisExpression.deserialize(bytes);
  }
}
export class TemplateLiteral extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          quasis?: Node[];
          expressions?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [1, 2],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('quasis' in data && data.quasis != undefined) {
        this.quasis = data.quasis;
      }
      if ('expressions' in data && data.expressions != undefined) {
        this.expressions = data.expressions;
      }
    }
  }
  get quasis() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set quasis(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  get expressions() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set expressions(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    quasis?: ReturnType<typeof Node.prototype.toObject>[];
    expressions?: ReturnType<typeof Node.prototype.toObject>[];
  }): TemplateLiteral {
    const message = new TemplateLiteral({});
    if (data.quasis != null) {
      message.quasis = data.quasis.map(item => Node.fromObject(item));
    }
    if (data.expressions != null) {
      message.expressions = data.expressions.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      quasis?: ReturnType<typeof Node.prototype.toObject>[];
      expressions?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.quasis != null) {
      data.quasis = this.quasis.map((item: Node) => item.toObject());
    }
    if (this.expressions != null) {
      data.expressions = this.expressions.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.quasis.length)
      writer.writeRepeatedMessage(1, this.quasis, (item: Node) => item.serialize(writer));
    if (this.expressions.length)
      writer.writeRepeatedMessage(2, this.expressions, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TemplateLiteral {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new TemplateLiteral();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.quasis, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        case 2:
          reader.readMessage(message.expressions, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): TemplateLiteral {
    return TemplateLiteral.deserialize(bytes);
  }
}
export class TaggedTemplateExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          tag?: Node;
          quasi?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('tag' in data && data.tag != undefined) {
        this.tag = data.tag;
      }
      if ('quasi' in data && data.quasi != undefined) {
        this.quasi = data.quasi;
      }
    }
  }
  get tag() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set tag(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_tag() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get quasi() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set quasi(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_quasi() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    tag?: ReturnType<typeof Node.prototype.toObject>;
    quasi?: ReturnType<typeof Node.prototype.toObject>;
  }): TaggedTemplateExpression {
    const message = new TaggedTemplateExpression({});
    if (data.tag != null) {
      message.tag = Node.fromObject(data.tag);
    }
    if (data.quasi != null) {
      message.quasi = Node.fromObject(data.quasi);
    }
    return message;
  }
  toObject() {
    const data: {
      tag?: ReturnType<typeof Node.prototype.toObject>;
      quasi?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.tag != null) {
      data.tag = this.tag.toObject();
    }
    if (this.quasi != null) {
      data.quasi = this.quasi.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_tag) writer.writeMessage(1, this.tag, () => this.tag.serialize(writer));
    if (this.has_quasi) writer.writeMessage(2, this.quasi, () => this.quasi.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TaggedTemplateExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new TaggedTemplateExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.tag, () => (message.tag = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.quasi, () => (message.quasi = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): TaggedTemplateExpression {
    return TaggedTemplateExpression.deserialize(bytes);
  }
}
export class SequenceExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          expressions?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('expressions' in data && data.expressions != undefined) {
        this.expressions = data.expressions;
      }
    }
  }
  get expressions() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set expressions(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    expressions?: ReturnType<typeof Node.prototype.toObject>[];
  }): SequenceExpression {
    const message = new SequenceExpression({});
    if (data.expressions != null) {
      message.expressions = data.expressions.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      expressions?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.expressions != null) {
      data.expressions = this.expressions.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.expressions.length)
      writer.writeRepeatedMessage(1, this.expressions, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SequenceExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SequenceExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.expressions, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SequenceExpression {
    return SequenceExpression.deserialize(bytes);
  }
}
export class ObjectExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          properties?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('properties' in data && data.properties != undefined) {
        this.properties = data.properties;
      }
    }
  }
  get properties() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set properties(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    properties?: ReturnType<typeof Node.prototype.toObject>[];
  }): ObjectExpression {
    const message = new ObjectExpression({});
    if (data.properties != null) {
      message.properties = data.properties.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      properties?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.properties != null) {
      data.properties = this.properties.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.properties.length)
      writer.writeRepeatedMessage(1, this.properties, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObjectExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ObjectExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.properties, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ObjectExpression {
    return ObjectExpression.deserialize(bytes);
  }
}
export class SpreadElement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    argument?: ReturnType<typeof Node.prototype.toObject>;
  }): SpreadElement {
    const message = new SpreadElement({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SpreadElement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SpreadElement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SpreadElement {
    return SpreadElement.deserialize(bytes);
  }
}
export class Property extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          key?: Node;
          value?: Node;
          kind?: string;
          method?: boolean;
          shorthand?: boolean;
          computed?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('key' in data && data.key != undefined) {
        this.key = data.key;
      }
      if ('value' in data && data.value != undefined) {
        this.value = data.value;
      }
      if ('kind' in data && data.kind != undefined) {
        this.kind = data.kind;
      }
      if ('method' in data && data.method != undefined) {
        this.method = data.method;
      }
      if ('shorthand' in data && data.shorthand != undefined) {
        this.shorthand = data.shorthand;
      }
      if ('computed' in data && data.computed != undefined) {
        this.computed = data.computed;
      }
    }
  }
  get key() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set key(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_key() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get value() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set value(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_value() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get kind() {
    return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
  }
  set kind(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  get method() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set method(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get shorthand() {
    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
  }
  set shorthand(value: boolean) {
    pb_1.Message.setField(this, 5, value);
  }
  get computed() {
    return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
  }
  set computed(value: boolean) {
    pb_1.Message.setField(this, 6, value);
  }
  static fromObject(data: {
    key?: ReturnType<typeof Node.prototype.toObject>;
    value?: ReturnType<typeof Node.prototype.toObject>;
    kind?: string;
    method?: boolean;
    shorthand?: boolean;
    computed?: boolean;
  }): Property {
    const message = new Property({});
    if (data.key != null) {
      message.key = Node.fromObject(data.key);
    }
    if (data.value != null) {
      message.value = Node.fromObject(data.value);
    }
    if (data.kind != null) {
      message.kind = data.kind;
    }
    if (data.method != null) {
      message.method = data.method;
    }
    if (data.shorthand != null) {
      message.shorthand = data.shorthand;
    }
    if (data.computed != null) {
      message.computed = data.computed;
    }
    return message;
  }
  toObject() {
    const data: {
      key?: ReturnType<typeof Node.prototype.toObject>;
      value?: ReturnType<typeof Node.prototype.toObject>;
      kind?: string;
      method?: boolean;
      shorthand?: boolean;
      computed?: boolean;
    } = {};
    if (this.key != null) {
      data.key = this.key.toObject();
    }
    if (this.value != null) {
      data.value = this.value.toObject();
    }
    if (this.kind != null) {
      data.kind = this.kind;
    }
    if (this.method != null) {
      data.method = this.method;
    }
    if (this.shorthand != null) {
      data.shorthand = this.shorthand;
    }
    if (this.computed != null) {
      data.computed = this.computed;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_key) writer.writeMessage(1, this.key, () => this.key.serialize(writer));
    if (this.has_value) writer.writeMessage(2, this.value, () => this.value.serialize(writer));
    if (this.kind.length) writer.writeString(3, this.kind);
    if (this.method != false) writer.writeBool(4, this.method);
    if (this.shorthand != false) writer.writeBool(5, this.shorthand);
    if (this.computed != false) writer.writeBool(6, this.computed);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Property {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Property();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.key, () => (message.key = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.value, () => (message.value = Node.deserialize(reader)));
          break;
        case 3:
          message.kind = reader.readString();
          break;
        case 4:
          message.method = reader.readBool();
          break;
        case 5:
          message.shorthand = reader.readBool();
          break;
        case 6:
          message.computed = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Property {
    return Property.deserialize(bytes);
  }
}
export class AssignmentPattern extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          left?: Node;
          right?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
    }
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
  }): AssignmentPattern {
    const message = new AssignmentPattern({});
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    return message;
  }
  toObject() {
    const data: {
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_left) writer.writeMessage(1, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(2, this.right, () => this.right.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AssignmentPattern {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new AssignmentPattern();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): AssignmentPattern {
    return AssignmentPattern.deserialize(bytes);
  }
}
export class RestElement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: { argument?: ReturnType<typeof Node.prototype.toObject> }): RestElement {
    const message = new RestElement({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RestElement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new RestElement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): RestElement {
    return RestElement.deserialize(bytes);
  }
}
export class ArrayPattern extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          elements?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('elements' in data && data.elements != undefined) {
        this.elements = data.elements;
      }
    }
  }
  get elements() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set elements(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    elements?: ReturnType<typeof Node.prototype.toObject>[];
  }): ArrayPattern {
    const message = new ArrayPattern({});
    if (data.elements != null) {
      message.elements = data.elements.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      elements?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.elements != null) {
      data.elements = this.elements.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.elements.length)
      writer.writeRepeatedMessage(1, this.elements, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ArrayPattern {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ArrayPattern();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.elements, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ArrayPattern {
    return ArrayPattern.deserialize(bytes);
  }
}
export class ObjectPattern extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          properties?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('properties' in data && data.properties != undefined) {
        this.properties = data.properties;
      }
    }
  }
  get properties() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set properties(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    properties?: ReturnType<typeof Node.prototype.toObject>[];
  }): ObjectPattern {
    const message = new ObjectPattern({});
    if (data.properties != null) {
      message.properties = data.properties.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      properties?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.properties != null) {
      data.properties = this.properties.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.properties.length)
      writer.writeRepeatedMessage(1, this.properties, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObjectPattern {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ObjectPattern();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.properties, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ObjectPattern {
    return ObjectPattern.deserialize(bytes);
  }
}
export class PrivateIdentifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          name?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('name' in data && data.name != undefined) {
        this.name = data.name;
      }
    }
  }
  get name() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set name(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  static fromObject(data: { name?: string }): PrivateIdentifier {
    const message = new PrivateIdentifier({});
    if (data.name != null) {
      message.name = data.name;
    }
    return message;
  }
  toObject() {
    const data: {
      name?: string;
    } = {};
    if (this.name != null) {
      data.name = this.name;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.name.length) writer.writeString(1, this.name);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PrivateIdentifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new PrivateIdentifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.name = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): PrivateIdentifier {
    return PrivateIdentifier.deserialize(bytes);
  }
}
export class NewExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          callee?: Node;
          arguments?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('callee' in data && data.callee != undefined) {
        this.callee = data.callee;
      }
      if ('arguments' in data && data.arguments != undefined) {
        this.arguments = data.arguments;
      }
    }
  }
  get callee() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set callee(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_callee() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get arguments() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set arguments(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    callee?: ReturnType<typeof Node.prototype.toObject>;
    arguments?: ReturnType<typeof Node.prototype.toObject>[];
  }): NewExpression {
    const message = new NewExpression({});
    if (data.callee != null) {
      message.callee = Node.fromObject(data.callee);
    }
    if (data.arguments != null) {
      message.arguments = data.arguments.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      callee?: ReturnType<typeof Node.prototype.toObject>;
      arguments?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.callee != null) {
      data.callee = this.callee.toObject();
    }
    if (this.arguments != null) {
      data.arguments = this.arguments.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_callee) writer.writeMessage(1, this.callee, () => this.callee.serialize(writer));
    if (this.arguments.length)
      writer.writeRepeatedMessage(2, this.arguments, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NewExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new NewExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.callee, () => (message.callee = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.arguments, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): NewExpression {
    return NewExpression.deserialize(bytes);
  }
}
export class Super extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(data?: any[] | {}) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
    }
  }
  static fromObject(data: {}): Super {
    const message = new Super({});
    return message;
  }
  toObject() {
    const data: {} = {};
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Super {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Super();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Super {
    return Super.deserialize(bytes);
  }
}
export class MetaProperty extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          meta?: Node;
          property?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('meta' in data && data.meta != undefined) {
        this.meta = data.meta;
      }
      if ('property' in data && data.property != undefined) {
        this.property = data.property;
      }
    }
  }
  get meta() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set meta(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_meta() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get property() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set property(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_property() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    meta?: ReturnType<typeof Node.prototype.toObject>;
    property?: ReturnType<typeof Node.prototype.toObject>;
  }): MetaProperty {
    const message = new MetaProperty({});
    if (data.meta != null) {
      message.meta = Node.fromObject(data.meta);
    }
    if (data.property != null) {
      message.property = Node.fromObject(data.property);
    }
    return message;
  }
  toObject() {
    const data: {
      meta?: ReturnType<typeof Node.prototype.toObject>;
      property?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.meta != null) {
      data.meta = this.meta.toObject();
    }
    if (this.property != null) {
      data.property = this.property.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_meta) writer.writeMessage(1, this.meta, () => this.meta.serialize(writer));
    if (this.has_property)
      writer.writeMessage(2, this.property, () => this.property.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetaProperty {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new MetaProperty();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.meta, () => (message.meta = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.property, () => (message.property = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MetaProperty {
    return MetaProperty.deserialize(bytes);
  }
}
export class MemberExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          object?: Node;
          property?: Node;
          computed?: boolean;
          optional?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('object' in data && data.object != undefined) {
        this.object = data.object;
      }
      if ('property' in data && data.property != undefined) {
        this.property = data.property;
      }
      if ('computed' in data && data.computed != undefined) {
        this.computed = data.computed;
      }
      if ('optional' in data && data.optional != undefined) {
        this.optional = data.optional;
      }
    }
  }
  get object() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set object(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_object() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get property() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set property(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_property() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get computed() {
    return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
  }
  set computed(value: boolean) {
    pb_1.Message.setField(this, 3, value);
  }
  get optional() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set optional(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  static fromObject(data: {
    object?: ReturnType<typeof Node.prototype.toObject>;
    property?: ReturnType<typeof Node.prototype.toObject>;
    computed?: boolean;
    optional?: boolean;
  }): MemberExpression {
    const message = new MemberExpression({});
    if (data.object != null) {
      message.object = Node.fromObject(data.object);
    }
    if (data.property != null) {
      message.property = Node.fromObject(data.property);
    }
    if (data.computed != null) {
      message.computed = data.computed;
    }
    if (data.optional != null) {
      message.optional = data.optional;
    }
    return message;
  }
  toObject() {
    const data: {
      object?: ReturnType<typeof Node.prototype.toObject>;
      property?: ReturnType<typeof Node.prototype.toObject>;
      computed?: boolean;
      optional?: boolean;
    } = {};
    if (this.object != null) {
      data.object = this.object.toObject();
    }
    if (this.property != null) {
      data.property = this.property.toObject();
    }
    if (this.computed != null) {
      data.computed = this.computed;
    }
    if (this.optional != null) {
      data.optional = this.optional;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_object) writer.writeMessage(1, this.object, () => this.object.serialize(writer));
    if (this.has_property)
      writer.writeMessage(2, this.property, () => this.property.serialize(writer));
    if (this.computed != false) writer.writeBool(3, this.computed);
    if (this.optional != false) writer.writeBool(4, this.optional);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MemberExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new MemberExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.object, () => (message.object = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.property, () => (message.property = Node.deserialize(reader)));
          break;
        case 3:
          message.computed = reader.readBool();
          break;
        case 4:
          message.optional = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MemberExpression {
    return MemberExpression.deserialize(bytes);
  }
}
export class LogicalExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          operator?: Node;
          left?: Node;
          right?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('operator' in data && data.operator != undefined) {
        this.operator = data.operator;
      }
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
    }
  }
  get operator() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set operator(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_operator() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    operator?: ReturnType<typeof Node.prototype.toObject>;
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
  }): LogicalExpression {
    const message = new LogicalExpression({});
    if (data.operator != null) {
      message.operator = Node.fromObject(data.operator);
    }
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    return message;
  }
  toObject() {
    const data: {
      operator?: ReturnType<typeof Node.prototype.toObject>;
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.operator != null) {
      data.operator = this.operator.toObject();
    }
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_operator)
      writer.writeMessage(1, this.operator, () => this.operator.serialize(writer));
    if (this.has_left) writer.writeMessage(2, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(3, this.right, () => this.right.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LogicalExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new LogicalExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.operator, () => (message.operator = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): LogicalExpression {
    return LogicalExpression.deserialize(bytes);
  }
}
export class ImportExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          source?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('source' in data && data.source != undefined) {
        this.source = data.source;
      }
    }
  }
  get source() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set source(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_source() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    source?: ReturnType<typeof Node.prototype.toObject>;
  }): ImportExpression {
    const message = new ImportExpression({});
    if (data.source != null) {
      message.source = Node.fromObject(data.source);
    }
    return message;
  }
  toObject() {
    const data: {
      source?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.source != null) {
      data.source = this.source.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_source) writer.writeMessage(1, this.source, () => this.source.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ImportExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.source, () => (message.source = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImportExpression {
    return ImportExpression.deserialize(bytes);
  }
}
export class BlockStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          body?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get body() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set body(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: { body?: ReturnType<typeof Node.prototype.toObject>[] }): BlockStatement {
    const message = new BlockStatement({});
    if (data.body != null) {
      message.body = data.body.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      body?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.body != null) {
      data.body = this.body.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.body.length)
      writer.writeRepeatedMessage(1, this.body, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new BlockStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.body, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): BlockStatement {
    return BlockStatement.deserialize(bytes);
  }
}
export class ConditionalExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          test?: Node;
          alternate?: Node;
          consequent?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
      if ('alternate' in data && data.alternate != undefined) {
        this.alternate = data.alternate;
      }
      if ('consequent' in data && data.consequent != undefined) {
        this.consequent = data.consequent;
      }
    }
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get alternate() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set alternate(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_alternate() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get consequent() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set consequent(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_consequent() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    test?: ReturnType<typeof Node.prototype.toObject>;
    alternate?: ReturnType<typeof Node.prototype.toObject>;
    consequent?: ReturnType<typeof Node.prototype.toObject>;
  }): ConditionalExpression {
    const message = new ConditionalExpression({});
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    if (data.alternate != null) {
      message.alternate = Node.fromObject(data.alternate);
    }
    if (data.consequent != null) {
      message.consequent = Node.fromObject(data.consequent);
    }
    return message;
  }
  toObject() {
    const data: {
      test?: ReturnType<typeof Node.prototype.toObject>;
      alternate?: ReturnType<typeof Node.prototype.toObject>;
      consequent?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    if (this.alternate != null) {
      data.alternate = this.alternate.toObject();
    }
    if (this.consequent != null) {
      data.consequent = this.consequent.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_test) writer.writeMessage(1, this.test, () => this.test.serialize(writer));
    if (this.has_alternate)
      writer.writeMessage(2, this.alternate, () => this.alternate.serialize(writer));
    if (this.has_consequent)
      writer.writeMessage(3, this.consequent, () => this.consequent.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConditionalExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ConditionalExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(
            message.alternate,
            () => (message.alternate = Node.deserialize(reader)),
          );
          break;
        case 3:
          reader.readMessage(
            message.consequent,
            () => (message.consequent = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ConditionalExpression {
    return ConditionalExpression.deserialize(bytes);
  }
}
export class ClassExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          id?: Node;
          superClass?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('id' in data && data.id != undefined) {
        this.id = data.id;
      }
      if ('superClass' in data && data.superClass != undefined) {
        this.superClass = data.superClass;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get id() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set id(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_id() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get superClass() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set superClass(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_superClass() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    id?: ReturnType<typeof Node.prototype.toObject>;
    superClass?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): ClassExpression {
    const message = new ClassExpression({});
    if (data.id != null) {
      message.id = Node.fromObject(data.id);
    }
    if (data.superClass != null) {
      message.superClass = Node.fromObject(data.superClass);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      id?: ReturnType<typeof Node.prototype.toObject>;
      superClass?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.id != null) {
      data.id = this.id.toObject();
    }
    if (this.superClass != null) {
      data.superClass = this.superClass.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_id) writer.writeMessage(1, this.id, () => this.id.serialize(writer));
    if (this.has_superClass)
      writer.writeMessage(2, this.superClass, () => this.superClass.serialize(writer));
    if (this.has_body) writer.writeMessage(3, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClassExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ClassExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.id, () => (message.id = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(
            message.superClass,
            () => (message.superClass = Node.deserialize(reader)),
          );
          break;
        case 3:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ClassExpression {
    return ClassExpression.deserialize(bytes);
  }
}
export class ClassBody extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          body?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get body() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set body(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: { body?: ReturnType<typeof Node.prototype.toObject>[] }): ClassBody {
    const message = new ClassBody({});
    if (data.body != null) {
      message.body = data.body.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      body?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.body != null) {
      data.body = this.body.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.body.length)
      writer.writeRepeatedMessage(1, this.body, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ClassBody {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ClassBody();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.body, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ClassBody {
    return ClassBody.deserialize(bytes);
  }
}
export class StaticBlock extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(data?: any[] | {}) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
    }
  }
  static fromObject(data: {}): StaticBlock {
    const message = new StaticBlock({});
    return message;
  }
  toObject() {
    const data: {} = {};
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StaticBlock {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new StaticBlock();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): StaticBlock {
    return StaticBlock.deserialize(bytes);
  }
}
export class PropertyDefinition extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          key?: Node;
          value?: Node;
          computed?: boolean;
          static?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('key' in data && data.key != undefined) {
        this.key = data.key;
      }
      if ('value' in data && data.value != undefined) {
        this.value = data.value;
      }
      if ('computed' in data && data.computed != undefined) {
        this.computed = data.computed;
      }
      if ('static' in data && data.static != undefined) {
        this.static = data.static;
      }
    }
  }
  get key() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set key(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_key() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get value() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set value(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_value() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get computed() {
    return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
  }
  set computed(value: boolean) {
    pb_1.Message.setField(this, 3, value);
  }
  get static() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set static(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  static fromObject(data: {
    key?: ReturnType<typeof Node.prototype.toObject>;
    value?: ReturnType<typeof Node.prototype.toObject>;
    computed?: boolean;
    static?: boolean;
  }): PropertyDefinition {
    const message = new PropertyDefinition({});
    if (data.key != null) {
      message.key = Node.fromObject(data.key);
    }
    if (data.value != null) {
      message.value = Node.fromObject(data.value);
    }
    if (data.computed != null) {
      message.computed = data.computed;
    }
    if (data.static != null) {
      message.static = data.static;
    }
    return message;
  }
  toObject() {
    const data: {
      key?: ReturnType<typeof Node.prototype.toObject>;
      value?: ReturnType<typeof Node.prototype.toObject>;
      computed?: boolean;
      static?: boolean;
    } = {};
    if (this.key != null) {
      data.key = this.key.toObject();
    }
    if (this.value != null) {
      data.value = this.value.toObject();
    }
    if (this.computed != null) {
      data.computed = this.computed;
    }
    if (this.static != null) {
      data.static = this.static;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_key) writer.writeMessage(1, this.key, () => this.key.serialize(writer));
    if (this.has_value) writer.writeMessage(2, this.value, () => this.value.serialize(writer));
    if (this.computed != false) writer.writeBool(3, this.computed);
    if (this.static != false) writer.writeBool(4, this.static);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PropertyDefinition {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new PropertyDefinition();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.key, () => (message.key = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.value, () => (message.value = Node.deserialize(reader)));
          break;
        case 3:
          message.computed = reader.readBool();
          break;
        case 4:
          message.static = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): PropertyDefinition {
    return PropertyDefinition.deserialize(bytes);
  }
}
export class MethodDefinition extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          key?: Node;
          value?: Node;
          kind?: string;
          computed?: boolean;
          static?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('key' in data && data.key != undefined) {
        this.key = data.key;
      }
      if ('value' in data && data.value != undefined) {
        this.value = data.value;
      }
      if ('kind' in data && data.kind != undefined) {
        this.kind = data.kind;
      }
      if ('computed' in data && data.computed != undefined) {
        this.computed = data.computed;
      }
      if ('static' in data && data.static != undefined) {
        this.static = data.static;
      }
    }
  }
  get key() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set key(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_key() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get value() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set value(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_value() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get kind() {
    return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
  }
  set kind(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  get computed() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set computed(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get static() {
    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
  }
  set static(value: boolean) {
    pb_1.Message.setField(this, 5, value);
  }
  static fromObject(data: {
    key?: ReturnType<typeof Node.prototype.toObject>;
    value?: ReturnType<typeof Node.prototype.toObject>;
    kind?: string;
    computed?: boolean;
    static?: boolean;
  }): MethodDefinition {
    const message = new MethodDefinition({});
    if (data.key != null) {
      message.key = Node.fromObject(data.key);
    }
    if (data.value != null) {
      message.value = Node.fromObject(data.value);
    }
    if (data.kind != null) {
      message.kind = data.kind;
    }
    if (data.computed != null) {
      message.computed = data.computed;
    }
    if (data.static != null) {
      message.static = data.static;
    }
    return message;
  }
  toObject() {
    const data: {
      key?: ReturnType<typeof Node.prototype.toObject>;
      value?: ReturnType<typeof Node.prototype.toObject>;
      kind?: string;
      computed?: boolean;
      static?: boolean;
    } = {};
    if (this.key != null) {
      data.key = this.key.toObject();
    }
    if (this.value != null) {
      data.value = this.value.toObject();
    }
    if (this.kind != null) {
      data.kind = this.kind;
    }
    if (this.computed != null) {
      data.computed = this.computed;
    }
    if (this.static != null) {
      data.static = this.static;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_key) writer.writeMessage(1, this.key, () => this.key.serialize(writer));
    if (this.has_value) writer.writeMessage(2, this.value, () => this.value.serialize(writer));
    if (this.kind.length) writer.writeString(3, this.kind);
    if (this.computed != false) writer.writeBool(4, this.computed);
    if (this.static != false) writer.writeBool(5, this.static);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MethodDefinition {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new MethodDefinition();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.key, () => (message.key = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.value, () => (message.value = Node.deserialize(reader)));
          break;
        case 3:
          message.kind = reader.readString();
          break;
        case 4:
          message.computed = reader.readBool();
          break;
        case 5:
          message.static = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MethodDefinition {
    return MethodDefinition.deserialize(bytes);
  }
}
export class ChainExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          expression?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('expression' in data && data.expression != undefined) {
        this.expression = data.expression;
      }
    }
  }
  get expression() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set expression(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_expression() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    expression?: ReturnType<typeof Node.prototype.toObject>;
  }): ChainExpression {
    const message = new ChainExpression({});
    if (data.expression != null) {
      message.expression = Node.fromObject(data.expression);
    }
    return message;
  }
  toObject() {
    const data: {
      expression?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.expression != null) {
      data.expression = this.expression.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_expression)
      writer.writeMessage(1, this.expression, () => this.expression.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ChainExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ChainExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.expression,
            () => (message.expression = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ChainExpression {
    return ChainExpression.deserialize(bytes);
  }
}
export class SimpleCallExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          optional?: boolean;
          callee?: Node;
          arguments?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('optional' in data && data.optional != undefined) {
        this.optional = data.optional;
      }
      if ('callee' in data && data.callee != undefined) {
        this.callee = data.callee;
      }
      if ('arguments' in data && data.arguments != undefined) {
        this.arguments = data.arguments;
      }
    }
  }
  get optional() {
    return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
  }
  set optional(value: boolean) {
    pb_1.Message.setField(this, 1, value);
  }
  get callee() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set callee(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_callee() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get arguments() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 3) as Node[];
  }
  set arguments(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 3, value);
  }
  static fromObject(data: {
    optional?: boolean;
    callee?: ReturnType<typeof Node.prototype.toObject>;
    arguments?: ReturnType<typeof Node.prototype.toObject>[];
  }): SimpleCallExpression {
    const message = new SimpleCallExpression({});
    if (data.optional != null) {
      message.optional = data.optional;
    }
    if (data.callee != null) {
      message.callee = Node.fromObject(data.callee);
    }
    if (data.arguments != null) {
      message.arguments = data.arguments.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      optional?: boolean;
      callee?: ReturnType<typeof Node.prototype.toObject>;
      arguments?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.optional != null) {
      data.optional = this.optional;
    }
    if (this.callee != null) {
      data.callee = this.callee.toObject();
    }
    if (this.arguments != null) {
      data.arguments = this.arguments.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.optional != false) writer.writeBool(1, this.optional);
    if (this.has_callee) writer.writeMessage(2, this.callee, () => this.callee.serialize(writer));
    if (this.arguments.length)
      writer.writeRepeatedMessage(3, this.arguments, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimpleCallExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SimpleCallExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.optional = reader.readBool();
          break;
        case 2:
          reader.readMessage(message.callee, () => (message.callee = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.arguments, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 3, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SimpleCallExpression {
    return SimpleCallExpression.deserialize(bytes);
  }
}
export class BinaryExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          operator?: string;
          left?: Node;
          right?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('operator' in data && data.operator != undefined) {
        this.operator = data.operator;
      }
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
    }
  }
  get operator() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set operator(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    operator?: string;
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
  }): BinaryExpression {
    const message = new BinaryExpression({});
    if (data.operator != null) {
      message.operator = data.operator;
    }
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    return message;
  }
  toObject() {
    const data: {
      operator?: string;
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.operator != null) {
      data.operator = this.operator;
    }
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.operator.length) writer.writeString(1, this.operator);
    if (this.has_left) writer.writeMessage(2, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(3, this.right, () => this.right.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BinaryExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new BinaryExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.operator = reader.readString();
          break;
        case 2:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): BinaryExpression {
    return BinaryExpression.deserialize(bytes);
  }
}
export class AwaitExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    argument?: ReturnType<typeof Node.prototype.toObject>;
  }): AwaitExpression {
    const message = new AwaitExpression({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AwaitExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new AwaitExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): AwaitExpression {
    return AwaitExpression.deserialize(bytes);
  }
}
export class AssignmentExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          operator?: string;
          left?: Node;
          right?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('operator' in data && data.operator != undefined) {
        this.operator = data.operator;
      }
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
    }
  }
  get operator() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set operator(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    operator?: string;
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
  }): AssignmentExpression {
    const message = new AssignmentExpression({});
    if (data.operator != null) {
      message.operator = data.operator;
    }
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    return message;
  }
  toObject() {
    const data: {
      operator?: string;
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.operator != null) {
      data.operator = this.operator;
    }
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.operator.length) writer.writeString(1, this.operator);
    if (this.has_left) writer.writeMessage(2, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(3, this.right, () => this.right.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AssignmentExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new AssignmentExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.operator = reader.readString();
          break;
        case 2:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): AssignmentExpression {
    return AssignmentExpression.deserialize(bytes);
  }
}
export class ArrowFunctionExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          expression?: boolean;
          body?: Node;
          params?: Node[];
          generator?: boolean;
          async?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('expression' in data && data.expression != undefined) {
        this.expression = data.expression;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
      if ('params' in data && data.params != undefined) {
        this.params = data.params;
      }
      if ('generator' in data && data.generator != undefined) {
        this.generator = data.generator;
      }
      if ('async' in data && data.async != undefined) {
        this.async = data.async;
      }
    }
  }
  get expression() {
    return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
  }
  set expression(value: boolean) {
    pb_1.Message.setField(this, 1, value);
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get params() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 3) as Node[];
  }
  set params(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 3, value);
  }
  get generator() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set generator(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get async() {
    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
  }
  set async(value: boolean) {
    pb_1.Message.setField(this, 5, value);
  }
  static fromObject(data: {
    expression?: boolean;
    body?: ReturnType<typeof Node.prototype.toObject>;
    params?: ReturnType<typeof Node.prototype.toObject>[];
    generator?: boolean;
    async?: boolean;
  }): ArrowFunctionExpression {
    const message = new ArrowFunctionExpression({});
    if (data.expression != null) {
      message.expression = data.expression;
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    if (data.params != null) {
      message.params = data.params.map(item => Node.fromObject(item));
    }
    if (data.generator != null) {
      message.generator = data.generator;
    }
    if (data.async != null) {
      message.async = data.async;
    }
    return message;
  }
  toObject() {
    const data: {
      expression?: boolean;
      body?: ReturnType<typeof Node.prototype.toObject>;
      params?: ReturnType<typeof Node.prototype.toObject>[];
      generator?: boolean;
      async?: boolean;
    } = {};
    if (this.expression != null) {
      data.expression = this.expression;
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    if (this.params != null) {
      data.params = this.params.map((item: Node) => item.toObject());
    }
    if (this.generator != null) {
      data.generator = this.generator;
    }
    if (this.async != null) {
      data.async = this.async;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.expression != false) writer.writeBool(1, this.expression);
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (this.params.length)
      writer.writeRepeatedMessage(3, this.params, (item: Node) => item.serialize(writer));
    if (this.generator != false) writer.writeBool(4, this.generator);
    if (this.async != false) writer.writeBool(5, this.async);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ArrowFunctionExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ArrowFunctionExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.expression = reader.readBool();
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.params, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 3, Node.deserialize(reader), Node),
          );
          break;
        case 4:
          message.generator = reader.readBool();
          break;
        case 5:
          message.async = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ArrowFunctionExpression {
    return ArrowFunctionExpression.deserialize(bytes);
  }
}
export class ArrayExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          elements?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('elements' in data && data.elements != undefined) {
        this.elements = data.elements;
      }
    }
  }
  get elements() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set elements(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    elements?: ReturnType<typeof Node.prototype.toObject>[];
  }): ArrayExpression {
    const message = new ArrayExpression({});
    if (data.elements != null) {
      message.elements = data.elements.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      elements?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.elements != null) {
      data.elements = this.elements.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.elements.length)
      writer.writeRepeatedMessage(1, this.elements, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ArrayExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ArrayExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.elements, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ArrayExpression {
    return ArrayExpression.deserialize(bytes);
  }
}
export class MaybeNamedClassDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          id?: Node;
          superClass?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('id' in data && data.id != undefined) {
        this.id = data.id;
      }
      if ('superClass' in data && data.superClass != undefined) {
        this.superClass = data.superClass;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get id() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set id(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_id() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get superClass() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set superClass(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_superClass() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    id?: ReturnType<typeof Node.prototype.toObject>;
    superClass?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): MaybeNamedClassDeclaration {
    const message = new MaybeNamedClassDeclaration({});
    if (data.id != null) {
      message.id = Node.fromObject(data.id);
    }
    if (data.superClass != null) {
      message.superClass = Node.fromObject(data.superClass);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      id?: ReturnType<typeof Node.prototype.toObject>;
      superClass?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.id != null) {
      data.id = this.id.toObject();
    }
    if (this.superClass != null) {
      data.superClass = this.superClass.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_id) writer.writeMessage(1, this.id, () => this.id.serialize(writer));
    if (this.has_superClass)
      writer.writeMessage(2, this.superClass, () => this.superClass.serialize(writer));
    if (this.has_body) writer.writeMessage(3, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MaybeNamedClassDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new MaybeNamedClassDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.id, () => (message.id = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(
            message.superClass,
            () => (message.superClass = Node.deserialize(reader)),
          );
          break;
        case 3:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MaybeNamedClassDeclaration {
    return MaybeNamedClassDeclaration.deserialize(bytes);
  }
}
export class MaybeNamedFunctionDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          id?: Node;
          body?: Node;
          params?: Node[];
          generator?: boolean;
          async?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('id' in data && data.id != undefined) {
        this.id = data.id;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
      if ('params' in data && data.params != undefined) {
        this.params = data.params;
      }
      if ('generator' in data && data.generator != undefined) {
        this.generator = data.generator;
      }
      if ('async' in data && data.async != undefined) {
        this.async = data.async;
      }
    }
  }
  get id() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set id(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_id() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get params() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 3) as Node[];
  }
  set params(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 3, value);
  }
  get generator() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set generator(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get async() {
    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
  }
  set async(value: boolean) {
    pb_1.Message.setField(this, 5, value);
  }
  static fromObject(data: {
    id?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
    params?: ReturnType<typeof Node.prototype.toObject>[];
    generator?: boolean;
    async?: boolean;
  }): MaybeNamedFunctionDeclaration {
    const message = new MaybeNamedFunctionDeclaration({});
    if (data.id != null) {
      message.id = Node.fromObject(data.id);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    if (data.params != null) {
      message.params = data.params.map(item => Node.fromObject(item));
    }
    if (data.generator != null) {
      message.generator = data.generator;
    }
    if (data.async != null) {
      message.async = data.async;
    }
    return message;
  }
  toObject() {
    const data: {
      id?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
      params?: ReturnType<typeof Node.prototype.toObject>[];
      generator?: boolean;
      async?: boolean;
    } = {};
    if (this.id != null) {
      data.id = this.id.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    if (this.params != null) {
      data.params = this.params.map((item: Node) => item.toObject());
    }
    if (this.generator != null) {
      data.generator = this.generator;
    }
    if (this.async != null) {
      data.async = this.async;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_id) writer.writeMessage(1, this.id, () => this.id.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (this.params.length)
      writer.writeRepeatedMessage(3, this.params, (item: Node) => item.serialize(writer));
    if (this.generator != false) writer.writeBool(4, this.generator);
    if (this.async != false) writer.writeBool(5, this.async);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MaybeNamedFunctionDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new MaybeNamedFunctionDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.id, () => (message.id = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.params, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 3, Node.deserialize(reader), Node),
          );
          break;
        case 4:
          message.generator = reader.readBool();
          break;
        case 5:
          message.async = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): MaybeNamedFunctionDeclaration {
    return MaybeNamedFunctionDeclaration.deserialize(bytes);
  }
}
export class ExportNamedDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          declaration?: Node;
          specifiers?: Node[];
          source?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('declaration' in data && data.declaration != undefined) {
        this.declaration = data.declaration;
      }
      if ('specifiers' in data && data.specifiers != undefined) {
        this.specifiers = data.specifiers;
      }
      if ('source' in data && data.source != undefined) {
        this.source = data.source;
      }
    }
  }
  get declaration() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set declaration(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_declaration() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get specifiers() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set specifiers(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  get source() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set source(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_source() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    declaration?: ReturnType<typeof Node.prototype.toObject>;
    specifiers?: ReturnType<typeof Node.prototype.toObject>[];
    source?: ReturnType<typeof Node.prototype.toObject>;
  }): ExportNamedDeclaration {
    const message = new ExportNamedDeclaration({});
    if (data.declaration != null) {
      message.declaration = Node.fromObject(data.declaration);
    }
    if (data.specifiers != null) {
      message.specifiers = data.specifiers.map(item => Node.fromObject(item));
    }
    if (data.source != null) {
      message.source = Node.fromObject(data.source);
    }
    return message;
  }
  toObject() {
    const data: {
      declaration?: ReturnType<typeof Node.prototype.toObject>;
      specifiers?: ReturnType<typeof Node.prototype.toObject>[];
      source?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.declaration != null) {
      data.declaration = this.declaration.toObject();
    }
    if (this.specifiers != null) {
      data.specifiers = this.specifiers.map((item: Node) => item.toObject());
    }
    if (this.source != null) {
      data.source = this.source.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_declaration)
      writer.writeMessage(1, this.declaration, () => this.declaration.serialize(writer));
    if (this.specifiers.length)
      writer.writeRepeatedMessage(2, this.specifiers, (item: Node) => item.serialize(writer));
    if (this.has_source) writer.writeMessage(3, this.source, () => this.source.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExportNamedDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ExportNamedDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.declaration,
            () => (message.declaration = Node.deserialize(reader)),
          );
          break;
        case 2:
          reader.readMessage(message.specifiers, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        case 3:
          reader.readMessage(message.source, () => (message.source = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ExportNamedDeclaration {
    return ExportNamedDeclaration.deserialize(bytes);
  }
}
export class ExportSpecifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          exported?: Node;
          local?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('exported' in data && data.exported != undefined) {
        this.exported = data.exported;
      }
      if ('local' in data && data.local != undefined) {
        this.local = data.local;
      }
    }
  }
  get exported() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set exported(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_exported() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get local() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set local(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_local() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    exported?: ReturnType<typeof Node.prototype.toObject>;
    local?: ReturnType<typeof Node.prototype.toObject>;
  }): ExportSpecifier {
    const message = new ExportSpecifier({});
    if (data.exported != null) {
      message.exported = Node.fromObject(data.exported);
    }
    if (data.local != null) {
      message.local = Node.fromObject(data.local);
    }
    return message;
  }
  toObject() {
    const data: {
      exported?: ReturnType<typeof Node.prototype.toObject>;
      local?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.exported != null) {
      data.exported = this.exported.toObject();
    }
    if (this.local != null) {
      data.local = this.local.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_exported)
      writer.writeMessage(1, this.exported, () => this.exported.serialize(writer));
    if (this.has_local) writer.writeMessage(2, this.local, () => this.local.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExportSpecifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ExportSpecifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.exported, () => (message.exported = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.local, () => (message.local = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ExportSpecifier {
    return ExportSpecifier.deserialize(bytes);
  }
}
export class VariableDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          declarations?: Node[];
          kind?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('declarations' in data && data.declarations != undefined) {
        this.declarations = data.declarations;
      }
      if ('kind' in data && data.kind != undefined) {
        this.kind = data.kind;
      }
    }
  }
  get declarations() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set declarations(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  get kind() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set kind(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: {
    declarations?: ReturnType<typeof Node.prototype.toObject>[];
    kind?: string;
  }): VariableDeclaration {
    const message = new VariableDeclaration({});
    if (data.declarations != null) {
      message.declarations = data.declarations.map(item => Node.fromObject(item));
    }
    if (data.kind != null) {
      message.kind = data.kind;
    }
    return message;
  }
  toObject() {
    const data: {
      declarations?: ReturnType<typeof Node.prototype.toObject>[];
      kind?: string;
    } = {};
    if (this.declarations != null) {
      data.declarations = this.declarations.map((item: Node) => item.toObject());
    }
    if (this.kind != null) {
      data.kind = this.kind;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.declarations.length)
      writer.writeRepeatedMessage(1, this.declarations, (item: Node) => item.serialize(writer));
    if (this.kind.length) writer.writeString(2, this.kind);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VariableDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new VariableDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.declarations, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        case 2:
          message.kind = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): VariableDeclaration {
    return VariableDeclaration.deserialize(bytes);
  }
}
export class VariableDeclarator extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          id?: Node;
          init?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('id' in data && data.id != undefined) {
        this.id = data.id;
      }
      if ('init' in data && data.init != undefined) {
        this.init = data.init;
      }
    }
  }
  get id() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set id(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_id() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get init() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set init(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_init() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    id?: ReturnType<typeof Node.prototype.toObject>;
    init?: ReturnType<typeof Node.prototype.toObject>;
  }): VariableDeclarator {
    const message = new VariableDeclarator({});
    if (data.id != null) {
      message.id = Node.fromObject(data.id);
    }
    if (data.init != null) {
      message.init = Node.fromObject(data.init);
    }
    return message;
  }
  toObject() {
    const data: {
      id?: ReturnType<typeof Node.prototype.toObject>;
      init?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.id != null) {
      data.id = this.id.toObject();
    }
    if (this.init != null) {
      data.init = this.init.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_id) writer.writeMessage(1, this.id, () => this.id.serialize(writer));
    if (this.has_init) writer.writeMessage(2, this.init, () => this.init.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VariableDeclarator {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new VariableDeclarator();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.id, () => (message.id = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.init, () => (message.init = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): VariableDeclarator {
    return VariableDeclarator.deserialize(bytes);
  }
}
export class ImportDeclaration extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          specifiers?: Node[];
          source?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('specifiers' in data && data.specifiers != undefined) {
        this.specifiers = data.specifiers;
      }
      if ('source' in data && data.source != undefined) {
        this.source = data.source;
      }
    }
  }
  get specifiers() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 1) as Node[];
  }
  set specifiers(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  get source() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set source(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_source() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    specifiers?: ReturnType<typeof Node.prototype.toObject>[];
    source?: ReturnType<typeof Node.prototype.toObject>;
  }): ImportDeclaration {
    const message = new ImportDeclaration({});
    if (data.specifiers != null) {
      message.specifiers = data.specifiers.map(item => Node.fromObject(item));
    }
    if (data.source != null) {
      message.source = Node.fromObject(data.source);
    }
    return message;
  }
  toObject() {
    const data: {
      specifiers?: ReturnType<typeof Node.prototype.toObject>[];
      source?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.specifiers != null) {
      data.specifiers = this.specifiers.map((item: Node) => item.toObject());
    }
    if (this.source != null) {
      data.source = this.source.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.specifiers.length)
      writer.writeRepeatedMessage(1, this.specifiers, (item: Node) => item.serialize(writer));
    if (this.has_source) writer.writeMessage(2, this.source, () => this.source.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportDeclaration {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ImportDeclaration();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.specifiers, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 1, Node.deserialize(reader), Node),
          );
          break;
        case 2:
          reader.readMessage(message.source, () => (message.source = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImportDeclaration {
    return ImportDeclaration.deserialize(bytes);
  }
}
export class ImportNamespaceSpecifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          local?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('local' in data && data.local != undefined) {
        this.local = data.local;
      }
    }
  }
  get local() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set local(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_local() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    local?: ReturnType<typeof Node.prototype.toObject>;
  }): ImportNamespaceSpecifier {
    const message = new ImportNamespaceSpecifier({});
    if (data.local != null) {
      message.local = Node.fromObject(data.local);
    }
    return message;
  }
  toObject() {
    const data: {
      local?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.local != null) {
      data.local = this.local.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_local) writer.writeMessage(1, this.local, () => this.local.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportNamespaceSpecifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ImportNamespaceSpecifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.local, () => (message.local = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImportNamespaceSpecifier {
    return ImportNamespaceSpecifier.deserialize(bytes);
  }
}
export class ImportDefaultSpecifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          local?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('local' in data && data.local != undefined) {
        this.local = data.local;
      }
    }
  }
  get local() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set local(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_local() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    local?: ReturnType<typeof Node.prototype.toObject>;
  }): ImportDefaultSpecifier {
    const message = new ImportDefaultSpecifier({});
    if (data.local != null) {
      message.local = Node.fromObject(data.local);
    }
    return message;
  }
  toObject() {
    const data: {
      local?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.local != null) {
      data.local = this.local.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_local) writer.writeMessage(1, this.local, () => this.local.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportDefaultSpecifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ImportDefaultSpecifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.local, () => (message.local = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImportDefaultSpecifier {
    return ImportDefaultSpecifier.deserialize(bytes);
  }
}
export class ImportSpecifier extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          imported?: Node;
          local?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('imported' in data && data.imported != undefined) {
        this.imported = data.imported;
      }
      if ('local' in data && data.local != undefined) {
        this.local = data.local;
      }
    }
  }
  get imported() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set imported(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_imported() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get local() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set local(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_local() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    imported?: ReturnType<typeof Node.prototype.toObject>;
    local?: ReturnType<typeof Node.prototype.toObject>;
  }): ImportSpecifier {
    const message = new ImportSpecifier({});
    if (data.imported != null) {
      message.imported = Node.fromObject(data.imported);
    }
    if (data.local != null) {
      message.local = Node.fromObject(data.local);
    }
    return message;
  }
  toObject() {
    const data: {
      imported?: ReturnType<typeof Node.prototype.toObject>;
      local?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.imported != null) {
      data.imported = this.imported.toObject();
    }
    if (this.local != null) {
      data.local = this.local.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_imported)
      writer.writeMessage(1, this.imported, () => this.imported.serialize(writer));
    if (this.has_local) writer.writeMessage(2, this.local, () => this.local.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportSpecifier {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ImportSpecifier();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.imported, () => (message.imported = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.local, () => (message.local = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImportSpecifier {
    return ImportSpecifier.deserialize(bytes);
  }
}
export class ForOfStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          await?: boolean;
          left?: Node;
          right?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('await' in data && data.await != undefined) {
        this.await = data.await;
      }
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get await() {
    return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
  }
  set await(value: boolean) {
    pb_1.Message.setField(this, 1, value);
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 3) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 4) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 4, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 4) != null;
  }
  static fromObject(data: {
    await?: boolean;
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): ForOfStatement {
    const message = new ForOfStatement({});
    if (data.await != null) {
      message.await = data.await;
    }
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      await?: boolean;
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.await != null) {
      data.await = this.await;
    }
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.await != false) writer.writeBool(1, this.await);
    if (this.has_left) writer.writeMessage(2, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(3, this.right, () => this.right.serialize(writer));
    if (this.has_body) writer.writeMessage(4, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ForOfStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ForOfStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.await = reader.readBool();
          break;
        case 2:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        case 4:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ForOfStatement {
    return ForOfStatement.deserialize(bytes);
  }
}
export class ForInStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          left?: Node;
          right?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('left' in data && data.left != undefined) {
        this.left = data.left;
      }
      if ('right' in data && data.right != undefined) {
        this.right = data.right;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get left() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set left(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_left() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get right() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set right(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_right() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    left?: ReturnType<typeof Node.prototype.toObject>;
    right?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): ForInStatement {
    const message = new ForInStatement({});
    if (data.left != null) {
      message.left = Node.fromObject(data.left);
    }
    if (data.right != null) {
      message.right = Node.fromObject(data.right);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      left?: ReturnType<typeof Node.prototype.toObject>;
      right?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.left != null) {
      data.left = this.left.toObject();
    }
    if (this.right != null) {
      data.right = this.right.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_left) writer.writeMessage(1, this.left, () => this.left.serialize(writer));
    if (this.has_right) writer.writeMessage(2, this.right, () => this.right.serialize(writer));
    if (this.has_body) writer.writeMessage(3, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ForInStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ForInStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.left, () => (message.left = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.right, () => (message.right = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ForInStatement {
    return ForInStatement.deserialize(bytes);
  }
}
export class ForStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          init?: Node;
          test?: Node;
          update?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('init' in data && data.init != undefined) {
        this.init = data.init;
      }
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
      if ('update' in data && data.update != undefined) {
        this.update = data.update;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get init() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set init(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_init() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get update() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set update(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_update() {
    return pb_1.Message.getField(this, 3) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 4) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 4, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 4) != null;
  }
  static fromObject(data: {
    init?: ReturnType<typeof Node.prototype.toObject>;
    test?: ReturnType<typeof Node.prototype.toObject>;
    update?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): ForStatement {
    const message = new ForStatement({});
    if (data.init != null) {
      message.init = Node.fromObject(data.init);
    }
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    if (data.update != null) {
      message.update = Node.fromObject(data.update);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      init?: ReturnType<typeof Node.prototype.toObject>;
      test?: ReturnType<typeof Node.prototype.toObject>;
      update?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.init != null) {
      data.init = this.init.toObject();
    }
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    if (this.update != null) {
      data.update = this.update.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_init) writer.writeMessage(1, this.init, () => this.init.serialize(writer));
    if (this.has_test) writer.writeMessage(2, this.test, () => this.test.serialize(writer));
    if (this.has_update) writer.writeMessage(3, this.update, () => this.update.serialize(writer));
    if (this.has_body) writer.writeMessage(4, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ForStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ForStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.init, () => (message.init = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.update, () => (message.update = Node.deserialize(reader)));
          break;
        case 4:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ForStatement {
    return ForStatement.deserialize(bytes);
  }
}
export class DoWhileStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          body?: Node;
          test?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
    }
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    body?: ReturnType<typeof Node.prototype.toObject>;
    test?: ReturnType<typeof Node.prototype.toObject>;
  }): DoWhileStatement {
    const message = new DoWhileStatement({});
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    return message;
  }
  toObject() {
    const data: {
      body?: ReturnType<typeof Node.prototype.toObject>;
      test?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_body) writer.writeMessage(1, this.body, () => this.body.serialize(writer));
    if (this.has_test) writer.writeMessage(2, this.test, () => this.test.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DoWhileStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new DoWhileStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): DoWhileStatement {
    return DoWhileStatement.deserialize(bytes);
  }
}
export class WhileStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          test?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    test?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): WhileStatement {
    const message = new WhileStatement({});
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      test?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_test) writer.writeMessage(1, this.test, () => this.test.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WhileStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new WhileStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): WhileStatement {
    return WhileStatement.deserialize(bytes);
  }
}
export class TryStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          block?: Node;
          handler?: Node;
          finalizer?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('block' in data && data.block != undefined) {
        this.block = data.block;
      }
      if ('handler' in data && data.handler != undefined) {
        this.handler = data.handler;
      }
      if ('finalizer' in data && data.finalizer != undefined) {
        this.finalizer = data.finalizer;
      }
    }
  }
  get block() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set block(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_block() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get handler() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set handler(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_handler() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get finalizer() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set finalizer(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_finalizer() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    block?: ReturnType<typeof Node.prototype.toObject>;
    handler?: ReturnType<typeof Node.prototype.toObject>;
    finalizer?: ReturnType<typeof Node.prototype.toObject>;
  }): TryStatement {
    const message = new TryStatement({});
    if (data.block != null) {
      message.block = Node.fromObject(data.block);
    }
    if (data.handler != null) {
      message.handler = Node.fromObject(data.handler);
    }
    if (data.finalizer != null) {
      message.finalizer = Node.fromObject(data.finalizer);
    }
    return message;
  }
  toObject() {
    const data: {
      block?: ReturnType<typeof Node.prototype.toObject>;
      handler?: ReturnType<typeof Node.prototype.toObject>;
      finalizer?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.block != null) {
      data.block = this.block.toObject();
    }
    if (this.handler != null) {
      data.handler = this.handler.toObject();
    }
    if (this.finalizer != null) {
      data.finalizer = this.finalizer.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_block) writer.writeMessage(1, this.block, () => this.block.serialize(writer));
    if (this.has_handler)
      writer.writeMessage(2, this.handler, () => this.handler.serialize(writer));
    if (this.has_finalizer)
      writer.writeMessage(3, this.finalizer, () => this.finalizer.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TryStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new TryStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.block, () => (message.block = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.handler, () => (message.handler = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(
            message.finalizer,
            () => (message.finalizer = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): TryStatement {
    return TryStatement.deserialize(bytes);
  }
}
export class CatchClause extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          param?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('param' in data && data.param != undefined) {
        this.param = data.param;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get param() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set param(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_param() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    param?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): CatchClause {
    const message = new CatchClause({});
    if (data.param != null) {
      message.param = Node.fromObject(data.param);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      param?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.param != null) {
      data.param = this.param.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_param) writer.writeMessage(1, this.param, () => this.param.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CatchClause {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new CatchClause();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.param, () => (message.param = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): CatchClause {
    return CatchClause.deserialize(bytes);
  }
}
export class ThrowStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    argument?: ReturnType<typeof Node.prototype.toObject>;
  }): ThrowStatement {
    const message = new ThrowStatement({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThrowStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ThrowStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ThrowStatement {
    return ThrowStatement.deserialize(bytes);
  }
}
export class SwitchStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          discriminant?: Node;
          cases?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('discriminant' in data && data.discriminant != undefined) {
        this.discriminant = data.discriminant;
      }
      if ('cases' in data && data.cases != undefined) {
        this.cases = data.cases;
      }
    }
  }
  get discriminant() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set discriminant(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_discriminant() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get cases() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set cases(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    discriminant?: ReturnType<typeof Node.prototype.toObject>;
    cases?: ReturnType<typeof Node.prototype.toObject>[];
  }): SwitchStatement {
    const message = new SwitchStatement({});
    if (data.discriminant != null) {
      message.discriminant = Node.fromObject(data.discriminant);
    }
    if (data.cases != null) {
      message.cases = data.cases.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      discriminant?: ReturnType<typeof Node.prototype.toObject>;
      cases?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.discriminant != null) {
      data.discriminant = this.discriminant.toObject();
    }
    if (this.cases != null) {
      data.cases = this.cases.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_discriminant)
      writer.writeMessage(1, this.discriminant, () => this.discriminant.serialize(writer));
    if (this.cases.length)
      writer.writeRepeatedMessage(2, this.cases, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SwitchStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SwitchStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.discriminant,
            () => (message.discriminant = Node.deserialize(reader)),
          );
          break;
        case 2:
          reader.readMessage(message.cases, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SwitchStatement {
    return SwitchStatement.deserialize(bytes);
  }
}
export class SwitchCase extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          test?: Node;
          consequent?: Node[];
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
      if ('consequent' in data && data.consequent != undefined) {
        this.consequent = data.consequent;
      }
    }
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get consequent() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 2) as Node[];
  }
  set consequent(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    test?: ReturnType<typeof Node.prototype.toObject>;
    consequent?: ReturnType<typeof Node.prototype.toObject>[];
  }): SwitchCase {
    const message = new SwitchCase({});
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    if (data.consequent != null) {
      message.consequent = data.consequent.map(item => Node.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      test?: ReturnType<typeof Node.prototype.toObject>;
      consequent?: ReturnType<typeof Node.prototype.toObject>[];
    } = {};
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    if (this.consequent != null) {
      data.consequent = this.consequent.map((item: Node) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_test) writer.writeMessage(1, this.test, () => this.test.serialize(writer));
    if (this.consequent.length)
      writer.writeRepeatedMessage(2, this.consequent, (item: Node) => item.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SwitchCase {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new SwitchCase();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.consequent, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 2, Node.deserialize(reader), Node),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): SwitchCase {
    return SwitchCase.deserialize(bytes);
  }
}
export class IfStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          test?: Node;
          consequent?: Node;
          alternate?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('test' in data && data.test != undefined) {
        this.test = data.test;
      }
      if ('consequent' in data && data.consequent != undefined) {
        this.consequent = data.consequent;
      }
      if ('alternate' in data && data.alternate != undefined) {
        this.alternate = data.alternate;
      }
    }
  }
  get test() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set test(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_test() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get consequent() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set consequent(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_consequent() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get alternate() {
    return pb_1.Message.getWrapperField(this, Node, 3) as Node;
  }
  set alternate(value: Node) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_alternate() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    test?: ReturnType<typeof Node.prototype.toObject>;
    consequent?: ReturnType<typeof Node.prototype.toObject>;
    alternate?: ReturnType<typeof Node.prototype.toObject>;
  }): IfStatement {
    const message = new IfStatement({});
    if (data.test != null) {
      message.test = Node.fromObject(data.test);
    }
    if (data.consequent != null) {
      message.consequent = Node.fromObject(data.consequent);
    }
    if (data.alternate != null) {
      message.alternate = Node.fromObject(data.alternate);
    }
    return message;
  }
  toObject() {
    const data: {
      test?: ReturnType<typeof Node.prototype.toObject>;
      consequent?: ReturnType<typeof Node.prototype.toObject>;
      alternate?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.test != null) {
      data.test = this.test.toObject();
    }
    if (this.consequent != null) {
      data.consequent = this.consequent.toObject();
    }
    if (this.alternate != null) {
      data.alternate = this.alternate.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_test) writer.writeMessage(1, this.test, () => this.test.serialize(writer));
    if (this.has_consequent)
      writer.writeMessage(2, this.consequent, () => this.consequent.serialize(writer));
    if (this.has_alternate)
      writer.writeMessage(3, this.alternate, () => this.alternate.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IfStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new IfStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.test, () => (message.test = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(
            message.consequent,
            () => (message.consequent = Node.deserialize(reader)),
          );
          break;
        case 3:
          reader.readMessage(
            message.alternate,
            () => (message.alternate = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): IfStatement {
    return IfStatement.deserialize(bytes);
  }
}
export class ContinueStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          label?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('label' in data && data.label != undefined) {
        this.label = data.label;
      }
    }
  }
  get label() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set label(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_label() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    label?: ReturnType<typeof Node.prototype.toObject>;
  }): ContinueStatement {
    const message = new ContinueStatement({});
    if (data.label != null) {
      message.label = Node.fromObject(data.label);
    }
    return message;
  }
  toObject() {
    const data: {
      label?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.label != null) {
      data.label = this.label.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_label) writer.writeMessage(1, this.label, () => this.label.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContinueStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ContinueStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.label, () => (message.label = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ContinueStatement {
    return ContinueStatement.deserialize(bytes);
  }
}
export class BreakStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          label?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('label' in data && data.label != undefined) {
        this.label = data.label;
      }
    }
  }
  get label() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set label(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_label() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: { label?: ReturnType<typeof Node.prototype.toObject> }): BreakStatement {
    const message = new BreakStatement({});
    if (data.label != null) {
      message.label = Node.fromObject(data.label);
    }
    return message;
  }
  toObject() {
    const data: {
      label?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.label != null) {
      data.label = this.label.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_label) writer.writeMessage(1, this.label, () => this.label.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BreakStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new BreakStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.label, () => (message.label = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): BreakStatement {
    return BreakStatement.deserialize(bytes);
  }
}
export class LabeledStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          label?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('label' in data && data.label != undefined) {
        this.label = data.label;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get label() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set label(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_label() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    label?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): LabeledStatement {
    const message = new LabeledStatement({});
    if (data.label != null) {
      message.label = Node.fromObject(data.label);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      label?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.label != null) {
      data.label = this.label.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_label) writer.writeMessage(1, this.label, () => this.label.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LabeledStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new LabeledStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.label, () => (message.label = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): LabeledStatement {
    return LabeledStatement.deserialize(bytes);
  }
}
export class ReturnStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          argument?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('argument' in data && data.argument != undefined) {
        this.argument = data.argument;
      }
    }
  }
  get argument() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set argument(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_argument() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    argument?: ReturnType<typeof Node.prototype.toObject>;
  }): ReturnStatement {
    const message = new ReturnStatement({});
    if (data.argument != null) {
      message.argument = Node.fromObject(data.argument);
    }
    return message;
  }
  toObject() {
    const data: {
      argument?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.argument != null) {
      data.argument = this.argument.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_argument)
      writer.writeMessage(1, this.argument, () => this.argument.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReturnStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ReturnStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.argument, () => (message.argument = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ReturnStatement {
    return ReturnStatement.deserialize(bytes);
  }
}
export class WithStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          object?: Node;
          body?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('object' in data && data.object != undefined) {
        this.object = data.object;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
    }
  }
  get object() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set object(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_object() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    object?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
  }): WithStatement {
    const message = new WithStatement({});
    if (data.object != null) {
      message.object = Node.fromObject(data.object);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    return message;
  }
  toObject() {
    const data: {
      object?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.object != null) {
      data.object = this.object.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_object) writer.writeMessage(1, this.object, () => this.object.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WithStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new WithStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.object, () => (message.object = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): WithStatement {
    return WithStatement.deserialize(bytes);
  }
}
export class DebuggerStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(data?: any[] | {}) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
    }
  }
  static fromObject(data: {}): DebuggerStatement {
    const message = new DebuggerStatement({});
    return message;
  }
  toObject() {
    const data: {} = {};
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DebuggerStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new DebuggerStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): DebuggerStatement {
    return DebuggerStatement.deserialize(bytes);
  }
}
export class EmptyStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(data?: any[] | {}) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
    }
  }
  static fromObject(data: {}): EmptyStatement {
    const message = new EmptyStatement({});
    return message;
  }
  toObject() {
    const data: {} = {};
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EmptyStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new EmptyStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): EmptyStatement {
    return EmptyStatement.deserialize(bytes);
  }
}
export class ExpressionStatement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          expression?: Node;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('expression' in data && data.expression != undefined) {
        this.expression = data.expression;
      }
    }
  }
  get expression() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set expression(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_expression() {
    return pb_1.Message.getField(this, 1) != null;
  }
  static fromObject(data: {
    expression?: ReturnType<typeof Node.prototype.toObject>;
  }): ExpressionStatement {
    const message = new ExpressionStatement({});
    if (data.expression != null) {
      message.expression = Node.fromObject(data.expression);
    }
    return message;
  }
  toObject() {
    const data: {
      expression?: ReturnType<typeof Node.prototype.toObject>;
    } = {};
    if (this.expression != null) {
      data.expression = this.expression.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_expression)
      writer.writeMessage(1, this.expression, () => this.expression.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExpressionStatement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new ExpressionStatement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.expression,
            () => (message.expression = Node.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ExpressionStatement {
    return ExpressionStatement.deserialize(bytes);
  }
}
export class Directive extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          expression?: Node;
          directive?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('expression' in data && data.expression != undefined) {
        this.expression = data.expression;
      }
      if ('directive' in data && data.directive != undefined) {
        this.directive = data.directive;
      }
    }
  }
  get expression() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set expression(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_expression() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get directive() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set directive(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: {
    expression?: ReturnType<typeof Node.prototype.toObject>;
    directive?: string;
  }): Directive {
    const message = new Directive({});
    if (data.expression != null) {
      message.expression = Node.fromObject(data.expression);
    }
    if (data.directive != null) {
      message.directive = data.directive;
    }
    return message;
  }
  toObject() {
    const data: {
      expression?: ReturnType<typeof Node.prototype.toObject>;
      directive?: string;
    } = {};
    if (this.expression != null) {
      data.expression = this.expression.toObject();
    }
    if (this.directive != null) {
      data.directive = this.directive;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_expression)
      writer.writeMessage(1, this.expression, () => this.expression.serialize(writer));
    if (this.directive.length) writer.writeString(2, this.directive);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Directive {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new Directive();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(
            message.expression,
            () => (message.expression = Node.deserialize(reader)),
          );
          break;
        case 2:
          message.directive = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Directive {
    return Directive.deserialize(bytes);
  }
}
export class RegExpLiteral extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          pattern?: string;
          flags?: string;
          raw?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('pattern' in data && data.pattern != undefined) {
        this.pattern = data.pattern;
      }
      if ('flags' in data && data.flags != undefined) {
        this.flags = data.flags;
      }
      if ('raw' in data && data.raw != undefined) {
        this.raw = data.raw;
      }
    }
  }
  get pattern() {
    return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
  }
  set pattern(value: string) {
    pb_1.Message.setField(this, 1, value);
  }
  get flags() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set flags(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  get raw() {
    return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
  }
  set raw(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  static fromObject(data: { pattern?: string; flags?: string; raw?: string }): RegExpLiteral {
    const message = new RegExpLiteral({});
    if (data.pattern != null) {
      message.pattern = data.pattern;
    }
    if (data.flags != null) {
      message.flags = data.flags;
    }
    if (data.raw != null) {
      message.raw = data.raw;
    }
    return message;
  }
  toObject() {
    const data: {
      pattern?: string;
      flags?: string;
      raw?: string;
    } = {};
    if (this.pattern != null) {
      data.pattern = this.pattern;
    }
    if (this.flags != null) {
      data.flags = this.flags;
    }
    if (this.raw != null) {
      data.raw = this.raw;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.pattern.length) writer.writeString(1, this.pattern);
    if (this.flags.length) writer.writeString(2, this.flags);
    if (this.raw.length) writer.writeString(3, this.raw);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RegExpLiteral {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new RegExpLiteral();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.pattern = reader.readString();
          break;
        case 2:
          message.flags = reader.readString();
          break;
        case 3:
          message.raw = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): RegExpLiteral {
    return RegExpLiteral.deserialize(bytes);
  }
}
export class TemplateElement extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          tail?: boolean;
          cooked?: string;
          raw?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('tail' in data && data.tail != undefined) {
        this.tail = data.tail;
      }
      if ('cooked' in data && data.cooked != undefined) {
        this.cooked = data.cooked;
      }
      if ('raw' in data && data.raw != undefined) {
        this.raw = data.raw;
      }
    }
  }
  get tail() {
    return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
  }
  set tail(value: boolean) {
    pb_1.Message.setField(this, 1, value);
  }
  get cooked() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set cooked(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  get raw() {
    return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
  }
  set raw(value: string) {
    pb_1.Message.setField(this, 3, value);
  }
  static fromObject(data: { tail?: boolean; cooked?: string; raw?: string }): TemplateElement {
    const message = new TemplateElement({});
    if (data.tail != null) {
      message.tail = data.tail;
    }
    if (data.cooked != null) {
      message.cooked = data.cooked;
    }
    if (data.raw != null) {
      message.raw = data.raw;
    }
    return message;
  }
  toObject() {
    const data: {
      tail?: boolean;
      cooked?: string;
      raw?: string;
    } = {};
    if (this.tail != null) {
      data.tail = this.tail;
    }
    if (this.cooked != null) {
      data.cooked = this.cooked;
    }
    if (this.raw != null) {
      data.raw = this.raw;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.tail != false) writer.writeBool(1, this.tail);
    if (this.cooked.length) writer.writeString(2, this.cooked);
    if (this.raw.length) writer.writeString(3, this.raw);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TemplateElement {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new TemplateElement();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.tail = reader.readBool();
          break;
        case 2:
          message.cooked = reader.readString();
          break;
        case 3:
          message.raw = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): TemplateElement {
    return TemplateElement.deserialize(bytes);
  }
}
export class FunctionExpression extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          id?: Node;
          body?: Node;
          params?: Node[];
          generator?: boolean;
          async?: boolean;
        },
  ) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('id' in data && data.id != undefined) {
        this.id = data.id;
      }
      if ('body' in data && data.body != undefined) {
        this.body = data.body;
      }
      if ('params' in data && data.params != undefined) {
        this.params = data.params;
      }
      if ('generator' in data && data.generator != undefined) {
        this.generator = data.generator;
      }
      if ('async' in data && data.async != undefined) {
        this.async = data.async;
      }
    }
  }
  get id() {
    return pb_1.Message.getWrapperField(this, Node, 1) as Node;
  }
  set id(value: Node) {
    pb_1.Message.setWrapperField(this, 1, value);
  }
  get has_id() {
    return pb_1.Message.getField(this, 1) != null;
  }
  get body() {
    return pb_1.Message.getWrapperField(this, Node, 2) as Node;
  }
  set body(value: Node) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_body() {
    return pb_1.Message.getField(this, 2) != null;
  }
  get params() {
    return pb_1.Message.getRepeatedWrapperField(this, Node, 3) as Node[];
  }
  set params(value: Node[]) {
    pb_1.Message.setRepeatedWrapperField(this, 3, value);
  }
  get generator() {
    return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
  }
  set generator(value: boolean) {
    pb_1.Message.setField(this, 4, value);
  }
  get async() {
    return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
  }
  set async(value: boolean) {
    pb_1.Message.setField(this, 5, value);
  }
  static fromObject(data: {
    id?: ReturnType<typeof Node.prototype.toObject>;
    body?: ReturnType<typeof Node.prototype.toObject>;
    params?: ReturnType<typeof Node.prototype.toObject>[];
    generator?: boolean;
    async?: boolean;
  }): FunctionExpression {
    const message = new FunctionExpression({});
    if (data.id != null) {
      message.id = Node.fromObject(data.id);
    }
    if (data.body != null) {
      message.body = Node.fromObject(data.body);
    }
    if (data.params != null) {
      message.params = data.params.map(item => Node.fromObject(item));
    }
    if (data.generator != null) {
      message.generator = data.generator;
    }
    if (data.async != null) {
      message.async = data.async;
    }
    return message;
  }
  toObject() {
    const data: {
      id?: ReturnType<typeof Node.prototype.toObject>;
      body?: ReturnType<typeof Node.prototype.toObject>;
      params?: ReturnType<typeof Node.prototype.toObject>[];
      generator?: boolean;
      async?: boolean;
    } = {};
    if (this.id != null) {
      data.id = this.id.toObject();
    }
    if (this.body != null) {
      data.body = this.body.toObject();
    }
    if (this.params != null) {
      data.params = this.params.map((item: Node) => item.toObject());
    }
    if (this.generator != null) {
      data.generator = this.generator;
    }
    if (this.async != null) {
      data.async = this.async;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_id) writer.writeMessage(1, this.id, () => this.id.serialize(writer));
    if (this.has_body) writer.writeMessage(2, this.body, () => this.body.serialize(writer));
    if (this.params.length)
      writer.writeRepeatedMessage(3, this.params, (item: Node) => item.serialize(writer));
    if (this.generator != false) writer.writeBool(4, this.generator);
    if (this.async != false) writer.writeBool(5, this.async);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FunctionExpression {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
      message = new FunctionExpression();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.id, () => (message.id = Node.deserialize(reader)));
          break;
        case 2:
          reader.readMessage(message.body, () => (message.body = Node.deserialize(reader)));
          break;
        case 3:
          reader.readMessage(message.params, () =>
            pb_1.Message.addToRepeatedWrapperField(message, 3, Node.deserialize(reader), Node),
          );
          break;
        case 4:
          message.generator = reader.readBool();
          break;
        case 5:
          message.async = reader.readBool();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): FunctionExpression {
    return FunctionExpression.deserialize(bytes);
  }
}
