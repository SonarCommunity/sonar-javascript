diff --git a/node_modules/eslint/lib/linter/linter.js b/node_modules/eslint/lib/linter/linter.js
index 5c1a8d7..32c3f1f 100644
--- a/node_modules/eslint/lib/linter/linter.js
+++ b/node_modules/eslint/lib/linter/linter.js
@@ -32,7 +32,8 @@ const
     createEmitter = require("./safe-emitter"),
     SourceCodeFixer = require("./source-code-fixer"),
     timing = require("./timing"),
-    ruleReplacements = require("../../conf/replacements.json");
+    ruleReplacements = require("../../conf/replacements.json"),
+    patchClass = require("./patch-class");
 
 const debug = require("debug")("eslint:linter");
 const MAX_AUTOFIX_PASSES = 10;
@@ -837,6 +838,7 @@ function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parser
 
     Traverser.traverse(sourceCode.ast, {
         enter(node, parent) {
+            patchClass.patchIfClass(node);
             node.parent = parent;
             nodeQueue.push({ isEntering: true, node });
         },
diff --git a/node_modules/eslint/lib/linter/patch-class.js b/node_modules/eslint/lib/linter/patch-class.js
new file mode 100644
index 0000000..fb1eeca
--- /dev/null
+++ b/node_modules/eslint/lib/linter/patch-class.js
@@ -0,0 +1,245 @@
+// patch-start: patchClassBody
+
+/** Patches a node, if it is a class body */
+module.exports.patchIfClass = function(node) {
+  if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {
+    const hasExtends = !!node.superClass;
+    const classLoc = extractClassLocation(node);
+    patchClassBody(node.body, hasExtends, classLoc);
+  }
+}
+
+/** 
+ * Patches the class body by moving the instance fields inside of the constructor.
+ * 
+ * Goes through all class elements, 
+ * collects the instance properties into list,
+ * finds constructor along the way (if there is one),
+ * then transforms all properties into "roughly correct" field writes on `this`,
+ * and inserts them inside of the constructor node.
+ */
+function patchClassBody(classBody, hasExtends, classLoc) {
+  
+  // the constructor, initially undefined
+  let cons;
+  
+  // instance fields
+  const instanceFields = [];
+  
+  // Go through all class elements, collect the instance fields and constructor
+  for (const classElement of classBody.body) {
+    if (isConstructor(classElement)) {
+      cons = classElement;
+    } else if (isInstanceFieldWithInitializer(classElement)) {
+      instanceFields.push(classElement);
+      // Erase the initializer, but leave the ClassElement where it is,
+      // so that the syntactic rules still see the properties, but the frontend
+      // does not get confused with broken blocks generated by the
+      // initializers.
+      classElement.value = null;
+    }
+  }
+
+  // create a default constructor, if necessary
+  cons = cons || synthetizeDefaultConstructor(hasExtends, classLoc);
+
+  // insert all field initializers into the constructor
+  insertFields(instanceFields, cons);
+}
+
+/** Checks whether a node is a constructor */
+function isConstructor(classElem) {
+  return classElem.type === 'MethodDefinition' && classElem.kind === 'constructor';
+}
+
+/**
+ * Checks whether a node is a class instance field that 
+ * has to go inside of the constructor.
+ */
+function isInstanceFieldWithInitializer(classElem) {
+  return (
+    classElem.type === 'ClassProperty' &&
+    classElem.static === false &&
+    classElem.declare === false &&
+    classElem.value
+  );
+}
+
+/** Synthetizes a default constructor out of thin air */
+function synthetizeDefaultConstructor(hasExtends, loc) {
+  const e = constructorFunctionExpression(hasExtends, loc);
+  return constructorMethodDefinition(e, loc);
+}
+
+const MAX_SYNTHETIC_CONSTRUCTOR_PARAMS = 8;
+
+/** Creates the function expression for a synthetic constructor */
+function constructorFunctionExpression(hasExtends, loc) {
+  return {
+    type: 'FunctionExpression',
+    id: null,
+    params: constructorParams(MAX_SYNTHETIC_CONSTRUCTOR_PARAMS, loc),
+    generator: false,
+    expression: false, 
+    async: false,
+    body: constructorBody(hasExtends, loc),
+    range: loc,
+  };
+}
+
+function constructorParam(idx, loc) {
+  return {
+    type: 'Identifier',
+    name: `synthArg_${idx}`,
+    range: loc,
+  };
+}
+
+function constructorParams(n, loc) {
+  const res = [];
+  for (let i = 0; i < n; i++) {
+    res.push(constructorParam(i, loc));
+  }
+  return res;
+}
+
+function constructorBody(hasExtends, loc) {
+  return {
+    type: 'BlockStatement',
+    body: [...bodyStatements(hasExtends, loc)],
+    range: loc,
+  };
+}
+
+function superCall(loc) {
+  return {
+    type: 'ExpressionStatement',
+    expression: {
+      type: 'CallExpression',
+      callee: { type: 'Super', range: loc },
+      ['arguments']: constructorParams(MAX_SYNTHETIC_CONSTRUCTOR_PARAMS, loc),
+      optional: false,
+      range: loc,
+    },
+    range: loc,
+  };
+}
+
+function bodyStatements(hasExtends, loc) {
+  return hasExtends ? [ superCall(loc) ] : [];
+}
+
+/** Creates a `constructor` node with the given value. */
+function constructorMethodDefinition(value, loc) {
+ return {
+    type: 'MethodDefinition',
+    key: {
+      type: 'Identifier',
+      name: 'constructor',
+      range: loc,
+    },
+    value,
+    computed: false,
+    ['static']: false,
+    kind: 'constructor',
+    range: loc,
+  };
+}
+
+/**
+ * Attempts to extract the location of the head-part of a class 
+ * declaration or a class expression. 
+ */
+function extractClassLocation(classDecl) {
+  if (classDecl.id) {
+    return classDecl.id.range;
+  } else {
+    return classDecl.range;
+  }
+}
+
+/**
+ * Insert field initializers into constructor method definition.
+ */
+function insertFields(classProperties, cons) {
+  const funcExpr = cons.value;
+  const body = funcExpr.body;
+  if (body.type !== 'BlockStatement') {
+    // unclear what's going on here, ignore
+    return;
+  }
+
+  const originalStatements = body.body;
+  const patchedStatements = [];
+  let originalProcessedIdx = 0;
+
+  // process maybe the first super-call
+  if (originalStatements.length > 0) {
+    const firstStatement = originalStatements[0];
+    if (isSuperCall(firstStatement)) {
+      patchedStatements.push(firstStatement);
+      originalProcessedIdx = 1;
+    }
+  }
+
+  // now insert the properties (they must be able to override what was set in the `super`-call)
+  for (const p of classProperties) {
+    patchedStatements.push(classPropertyToStatement(p));
+  }
+
+  // add the remaining statements from the original constructor
+  for (let i = originalProcessedIdx; i < originalStatements.length; i++) {
+    patchedStatements.push(originalStatements[i]);
+  }
+
+  // set the body to the patched statements
+  body.body = patchedStatements;
+}
+
+/**
+ * Checks whether a statements looks like a `super(...)`-call
+ */
+function isSuperCall(stmt) {
+  return (
+    stmt.type === 'ExpressionStatement' &&
+    stmt.expression.type === 'CallExpression' &&
+    stmt.expression.callee.type === 'Super'
+  );
+}
+
+/**
+ * Converts an instance property into a statement that can be inserted between `super`-call
+ * and the rest of the constructor.
+ */
+function classPropertyToStatement(p) {
+  if (p.type !== 'ClassProperty') {
+    // Unclear, skip
+    return { type: 'EmptyStatement', range: p.range };
+  }
+
+  const { key, value, computed, range: loc } = p;
+  const thisExpr = { type: 'ThisExpression', range: loc };
+  const membExpr = {
+    type: 'MemberExpression',
+    object: thisExpr,
+    property: key,
+    computed,
+    optional: false,
+    range: loc,
+  };
+  const asgnExpr = {
+    type: 'AssignmentExpression',
+    operator: '=',
+    left: membExpr,
+    right: value,
+    range: loc,
+  };
+  return {
+    type: 'ExpressionStatement',
+    expression: asgnExpr,
+    range: loc,
+  };
+}
+
+// patch-end: patchClassBody
+
